[toc]



# 电商 - 支付常见问题

## 1.掉单问题

### 1.1.掉单异常

一个最常见的支付平台架构关系如下所示：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210422234813.jpeg)

> 上图我们是站在第三方支付公司支付角度，如果是自己公司的内部支付系统，那么外部商户这一块其实就是公司内部一些系统，比如说订单系统，而外部支付渠道其实就是第三方支付公司

我们以携程为例，在其上面发起一笔订单支付，将会经过三个系统：

1. 携程创建订单，向第三方支付公司发起支付请求
2. 第三方支付公司创建订单，并向工行发起支付请求
3. 工行完成扣款操作，返回第三方支付公司
4. 第三方支付完成订单更新并返回携程
5. 携程变更订单状态

上面的流程，简单如下图所示：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210422234835.jpeg)

在这个过程就可能会碰到，用户工行卡已经扣款，但是携程订单却还是待支付，我们通常将这种情况称为**掉单**。

上述掉单的场景，多数是因为**③、⑤**环节信息丢失导致，这种掉单我们将其称为**外部掉单**。

还有一种极少数的情况，收到 **③、⑤**环节返回信息，但是在**④、⑥**环节内部系统更新订单状态失败，从而导致丢失支付成功的信息，这类掉单由于是内部问题，我们通常将其称之为**内部掉单**。

### 1.2.外部掉单

外部掉单是因为没有收到对端返回信息，这种情况极有可能是网络问题，也有可能对端处理逻辑太慢，导致我方请求超时，直接断开了网络请求。

#### 1.2.1.增加超时时间

对于这种情况，第一个最简单的解决办法，**适当的增加超时时间**。

不过这里需要注意了，在我们增加网络超时时间之后，我们可能还需要调整整个链路的超时时间，不然有可能导致整个链路内部差事从而引起内部掉单。

> 画外音：对接外部渠道，一定要**设置网络连接超时时间与读取超时时间**。

#### 1.2.2.接收异步通知

第二个办法，接收渠道异步回执通知信息。

一般来说，现在支付渠道接口我们都可以上送一个异步回调地址，当渠道端处理成功，将会把成功信息通知到这个回调地址上。

这种情况下，我们只需要接收通知信息，然后解析，再更新内部订单状态。

![æ¯ä»ç³»ç»å¼å¸¸å¤ç-æ¯ä»å¼æ­¥éç¥](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210422235009.jpeg)

这种情况下，我们需要注意几点：

1. 对于异步请求信息，一定需要对通知内容进行签名验证，并校验返回的订单金额是否与商户侧的订单金额一致，防止数据泄漏导致出现“假通知”，造成资金损失。
2. 异步通知将会发送多次，所以异步通知处理需要幂等。

#### 1.2.3.掉单查询

有的渠道可能没有提供异步通知的功能，只提供了订单查询的接口，这种情况下，我们只能使用第三种解决办法，定时掉单查询。

我们可以将这类超时未知的订单的单独保存到掉单表，然后定时向渠道端查询订单的状态。

若查询成功或者明确失败（比如订单不存在等），可以更新订单状态，并且删除掉单表记录。

若查询依旧未知，这时我们需要等待下次查询的结果。

![æ¯ä»ç³»ç»å¼å¸¸å¤ç-å®æ¶æ¥è¯¢](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210422235037.jpeg)

这里我们需要注意了，有些情况下，有可能无法查询返回订单的状态，所以我们需要设置订单查询的最大次数，防止无限查询浪费性能。

#### 1.2.4.对账

最后，极少数的情况下，订单查询与异步通知都无法获取的支付结果，这就还剩下最后一种兜底的解决办法，对账。

如果第二天渠道端给的对账文件有这一笔支付结果，那么我们可以根据这个记录更新直接更新我们内部支付记录。

之前小黑哥写过一篇对账文章，感兴趣的可以再看一下：[聊聊对账系统的设计方案](https://mp.weixin.qq.com/s/47s0YdRM6u1JNngNe6yghg)

> 画外音：稳妥一点，可以先发起查询，然后根据查询结果更新订单记录。
>
> 不过有些极端情况，查询无法获取结果，那么直接更新内部记录即可。

那如果第二天也没有这笔记录的结果，这种情况下，我们可以认为这笔是失败的。如果用户被扣款，渠道端内部将会发起退款，将支付金额返回给用户。所以这种情况可以无需处理。

### 1.3.内部掉单异常

#### 1.3.1.支付公司内部订单关系

接下来我们讲下内部掉单异常，首先我们来看下为什么会发生内部掉单的异常，这其实跟我们系统架构有关。

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210422235111.jpeg)

如上图随所示，第三方支付公司内部表通常为支付订单与渠道订单这样一种 1 比 N 的关系。

支付订单保存着外部商户系统的订单号，代表第三方支付公司内部订单与外部商户的订单的关系。

而渠道订单代表着第三方支付公司与外部渠道的关系，其实对于外部渠道系统来讲，第三方支付公司就是一个外部商户。

为什么需要设计这种关系那？而不是使用下面这种 1 对 1 关系的那？

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210422235123.jpeg)

如果我们使用上图 1 对1 的订单关系，如果第一次支付支付失败，外部商户可能会再次使用相同订单号对第三方支付公司发起支付。

这时如果第三方支付公司也拿相同的内部订单去请求外部渠道系统，有可能外部渠道系统并不支持同一订单号再次请求。

那其实我们也有其他办法，生成一个新的内部单号，更新原有支付订单上内部记录，然后去请求外部渠道系统。但是这样的话就会丢失上次支付失败记录，这就不利于我们做一些事后统计了。

那其实第三方支付公司也可以不支持相同的订单号再次发起请求，但是这样的话，就需要外部商户重新生成的新的订单号。

这样的话，第三方支付公司是系统是简单了，全部复杂度都交给了外部商户。

但是现实的情况，很多外部商户并不是那么容易更换生成新的订单号，所以一般第三方支付公司都需要支持同一外部商户订单号在未成功的情况下，支持重复支付。

在这种情况下，就需要我们上面的 1:N 的订单关系图了。

#### 1.3.2.内部掉单异常的原因

当我们收到外部渠道系统的成功的返回信息，成功更新了渠道订单表的记录。但是由于渠道订单表与支付订单表可能不是同一个数据库，也有可能两者并不在同一个应用中，这就有可能导致更新支付订单表的更新失败。

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210422235142.jpeg)

由于支付订单是表保存着外部商户订单与内部订单关系，支付订单未成功，所以外部商户也无法查询得到成功的支付结果。

此时渠道订单表已经成功，所以上面外部掉单的方法并不适用内部掉单。

#### 1.3.3.内部掉单异常解决办法

**第一种解决办法，分布式事务。**

内部掉单异常，说白就是因为支付订单表与渠道订单表无法使用数据库事务保证两者同时更新成功或失败。

那么这种情况下，我们其实就需要使用分布式事务了。

不过我们没有采用这种分布式事务，一是因为之前开发的时候市面上并没有开源成熟分布式事务框架，第二自己自己开发难度又很大。

**第二种解决办法，异步补偿更新。**

当发生内部掉单的情况，即更新支付订单失败等情况，可以将这里支付订单保存到一张内部掉单表。

但是这里可能会有一个问题，我们无法保证保存到内部掉单表这一步骤也一定成功。

所以说，我们还需要定时查询，查询一段时间内支付订单未成功，而渠道订单表已成功的支付订单记录，然后也将其插入到内部掉单表。

另一个系统应用，只需要定时扫描内部掉单表，将支付订单成功，然后再删除内部掉单记录即可。

这里需要注意了，当支付订单表数据量很大之后，定时查询可能会慢，为了防止影响主库，所以这类查询可以在备库进行。

### 1.4.总结

今天主要介绍了支付系统中的掉单异常，这类异常往往会导致用户实际已经被扣钱，但是商户订单还是等待支付的情况。

这个异常如果没有很好处理，将会导致客户用户体验很不好，还有可能收到客户的投诉。

掉单的异常，通常可以外部系统与内部系统。而大部分的掉单都是因为外部系统导致，我们可以增加超时时间，掉单查询，以及接受异步通知解决 99% 的问题，剩下 1% 的掉单只能通过次日的对账来兜底。

内部系统导致掉单异常是典型的分布式环境数据一致性的问题，这类问题我们可以不需要追求强一致性，只要保证最终一致性即可。我们可以使用分布式事务解决这类问题，也可以定时扫描状态不一致的订单，然后在做批量更新。

### 1.5.具体实现

#### 1.5.1.定时轮询补偿方案

##### 1.5.1.1.整体流程

这个方案主要采用定时任务，批量查询掉单记录，从而驱动查询具体支付支付结果，然后更新内部订单。

整体方案流程图如下：

![å®æ¶ä»»å¡è¡¥å¿](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210422235627.jpeg)

前三步流程没什么好说的，正常的支付流程，咱们针对后面几步具体详细说下。

第三步调用支付通道之后，如果支付通道端返回**支付受理成功或者支付处理中**，我们就需要调用第四步，将这类订单插入掉单表。

如果支付直接成功了，那就正常流程返回即可。

> 复习一下，网关类支付，比如支付宝、微信支付、网银支付，这种支付模式，支付通道仅仅返回支付受理成功，具体支付结果需要接收支付通道端的支付通知，这类支付我们将其称为异步支付。
>
> 相应的还有同步支付，比如银行卡支付，微信、支付宝代扣类支付，这类支付，同步就能返回支付结果。

第五步，补单应用将会定时查询数据库，批量查询掉单记录。

第六步，补单应用使用线程池，多线程异步的方式发起掉单查询。

第七步，调用支付通道支付查询接口。

重点来了，如果第七步支付结果查询为以下状态：

- **支付结果为扣款成功**
- **支付结果为明确失败**
- **掉单记录查询达到最大次数**

**第八步就会删除掉单记录。**

最后，如果掉单查询依旧还是处理中，那么经过一定的延时之后，重复第五步，再次重新掉单补偿，直到成功或者查询到达最大次数。

##### 1.5.1.2.相关问题

**为什么需要新建一张掉单表？不能直接使用支付订单表，查询未成功的订单吗?**

这个问题，实际上确实可以直接使用的支付订单表，然后批量查询当天未成功的订单，补单程序发起支付查询。

*那为什么需要新建一张掉单表？*

主要是因为数据库查询效率问题，因为支付订单表每天都会大量记录新增，随着时间，这张表记录将会越来越多，越来越大。

**支付记录越多，批量范围查询效率就会变低，查询速度将会变慢。**

所以为了查询效率，新建一张掉单表。

这张表里仅记录支付未成功的订单，所以数据量就会很小，那么查询效率就会很高。

另外，掉单表里的记录，不会被永久保存，只是临时性。当支付结果查询成功，或者支付结果明确失败，再或者查询次数到达规定最大次数，就会删除掉单记录。

**这就是第八步为什么需要删除掉单表的原因。**

如果需要保存每次掉单表查询详情，那么这里建议再新增一张掉单查询记录表，保存每一次的查询记录。

针对这个方案，如果还有其他问题，欢迎留言。

##### 1.5.1.3.方案优缺点

定时轮询补偿方案，最大的优点可能就是系统架构方案比较简单，比较容易实施。

那么这个方案的缺点主要在于**定时任务**上。

定时任务轮询方案天然会存在以下不足：

1. **轮询效率稍低**
2. 每次查询数据库，已经被执行过记录，仍然会被扫描（补单程序将会根据一定策略决定是否发起支付通道查询），有**重复计算**的嫌疑
3. **时效性不够好**，如果每小时轮询一次，最差的情况下，时间误差会达到1小时
4. 如果为了解决时效性问题，增加定时任务查询效率，那么 1 中查询效率跟 2 的重复计算问题将会更加明显。

#### 1.5.2.延迟消息补偿方案

下面介绍另外一种掉单补偿方案，延迟消息补偿方案，这个方案整体流程与定时任务方案类似，最大区别可能在于，从一种**拉模式**变成一种**推模式**。

整体方案流程图如下：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210422235705.jpeg)

这个方案主要流程跟定时方案类似，主要区别在于第四步，第五步，第八步。

第四步的流程从插入掉单表变更为往**延迟队列发送掉单消息**。

第五步，补单程序接收掉单消息，然后触发支付掉单查询。

第八步，如果第七步支付结果查询为以下状态：

- 支付结果为扣款成功
- 支付结果为明确失败
- 掉单记录查询达到最大次数

补单程序将会告知延迟队列消费成功，延迟队列将会删除这条掉单消息。

其他状态将会告知消费失效，延迟队列将会在一定延时之后，再次发送掉单消息，然后继续重复第五步。

##### 1.5.2.1.延迟队列

这里的延迟队列需要自己实现，复杂度还是比较高的，这里给大家推荐几种实现方案：

第一种，基于 **Redis SortedSet** 实现延迟队列。可以参考一下有赞的实现方案https://tech.youzan.com/queuing_delay/

第二种，基于时间轮算法(**TimingWheel**)实现延迟队列，具体可以参考 Kafka 延时队列。

第三种，基于 **RocketMQ** 延迟消息。

前两种方案说起来还需要再开发，所以还是比较复杂的。

这里重点说下第三种方案，该方案是 **RocketMQ** 已经支持的特性，开箱即用，使用起来还是比较简单的。

RocketMQ 延迟消息支持 18 个等级，分别如下：

```shell
1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
```

消息发送方可以通过以下方式指定延迟等级，对应上方的延迟时间。

```java
Message#setDelayTimeLevel
```

消息消费方，如果消费失败，默认将会在消息发送方的的延迟等级基础上加 1。如果消息消费方需要指定其他的延迟等级，可以使用如下方式：

```java
ConsumeConcurrentlyContext#setDelayLevelWhenNextConsume
```

RocketMQ 延迟消息，支持的特性还是比较基础、简单，不支持自定义延迟时间。不过对于掉单补偿的这个场景刚好够用，但是如果需要自定义延迟的，那还是得采用其他的方案。

##### 1.5.2.2.方案优缺点

延迟消息的方案相对于定时轮询方案来讲：

- 无需再查询全部订单，效率高
- 时效性较好

不过延迟消息这种方案，需要基于**延迟队列**，实现起来比较复杂，目前开源实现也比较少。

#### 1.5.3.小结

支付掉单、卡单是支付过程中经常会碰到的事，我们可以采用异步补偿的方案，解决该问题。

异步补偿方案可以采用如下两种：

- 定时轮询补偿方案
- 延迟消息补偿方案

定时轮询补偿方案实现起来比较简单，但是时效性稍差。

而延迟消息补偿方案总体来说比较优秀，但是实现起来比较复杂。如果没有自定义的延迟时间的需求，可以直接采用 RocketMQ 延迟消息，简单快捷。

另外**延迟队列**使用场景还是比较多，不仅仅能用在掉单补偿上，还可以用于支付关单等场景。所以有能力开发的团队，可以开发一个通用的延迟队列、



## 2.重复付款异常

### 2.1.异常场景

重复付款异常一般常见于网银支付，微信支付，支付宝等这类需要跳转到一个支付网关页（网银支付），或者跳转到钱包 APP(支付宝、微信)，从而异步完成扣款的支付场景。

![网银支付流程](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000047.jpeg)

这种支付场景下，只能通过接受异步通知才能知道支付结果，我们一般将其称为异步支付。

> PS：有了异步支付，那么同步支付是什么？
>
> 其实同步支付指的就是调用支付接口之后，就可以立刻返回支付结果的，比如银行卡类快捷/代扣等支付就是同步支付。
>
> 当然也有一些奇葩的银行卡支付渠道，同步支付结果为受理成功，只能接受异步通知或者查询返回支付结果。
>
> 由于银行卡支付需要返回明确支付结果，对于这类渠道只能内部设计将异步转为同步
>

后台支付流程如下：

![ç½å³æ¯ä»](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000102.jpeg)

### 2.2.为什么会发生重复付款？

主要原因其实跟上次内部掉单异常一样，跟业务表设计有关。

上次我们提到，支付系统主要表结构如下：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000112.jpeg)

在这个表结构下，只要支付订单未成功，商户就可以重复使用其内部同一订单号调用支付接口。

假设这样一个场景，用户在收银台支付时选择招行进行网银支付，当他点击支付之后，商户系统将会调用支付公司的网银接口。

这时支付系统内部将会创建一笔支付单以及关联的渠道订单，并且调用招行系统的接口。

然后用户的浏览器页面将会打开一个新页面，然后跳转到招行网站。

这时如果此时用户再次在收银台点击支付，将会再次调用支付系统接口。这时候由于支付单已存在，所以仅仅会再创建一条渠道订单记录，并且调用招行系统的接口。这时用户的浏览器将会再次打开一个招行的网站。

*如果用户在两个招行网银页都完成支付，这时就发生了重复付款。*

上面这种场景看起来有点傻,但是真实用户操作真的会发生。除了这种，博客园上的小伙伴还提到这么下面这种情况：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000136.jpeg)

### 2.3.解决办法

重复付款异常的主要的解决办法有两种，分为事前与事后。

事前主要的目是尽可能防止用户重复付款，主要解决办法为优化付款页面，尽可能做好提示。

**第一种优化方式，付款页面直接跳转到第三方/银行的网银页面，不要打开新的页面去跳转。**

![网银同步跳转](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000148.gif)

这种方式可以防止用户误打开两个网银付款的页面，从而导致重复付款。

但是这里会有一个问题，银行网银页面付款成功之后，用户如何知道其在商户侧订单状态也成功了？

其实很简单，现在网银支付接口，一般都会有一个参数 `return_url:同步跳转地址` 。

![来自支付宝开发文档](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000158.jpeg)

只要在接口传入这个地址，当支付成功之后，页面最终就会跳转到这个传入的地址，商户侧就可以在地址显示订单是否支付成功。

![支付系统异常处理-同步跳转](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000205.jpeg)

上面我们提到，用户有可能会使用浏览器回退功能，跳转到支付页，从而导致重复付款。

对于这种情况，我们可以在其回退支付页时，首先向后台查询这笔订单支付结果，如果已支付成功，那就直接显示成功页面。

**第二种优化，对于这种重新打开一个页面跳转到银行网站，我们可以在页面加入弹窗提示，询问用户是否已支付完成。**

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000212.png)

比如上面这种处理方式，当用户点击确认完成充值，可以马上向后台发起查询订单状态。

下面来聊聊事后的解决办法，**其实解决办法很简单，发起内部退款，将多余支付的一笔反向退款回去**。

支付系统内部可以有个定时任务，定时扫描支付单下有多条成功渠道订单的记录，然后选择将重复支付渠道订单发起退款。

这种方式是支付公司系统内部的操作，不需要商户侧发起指令。

## 3.订单失效异常

### 3.1.异常场景

这种场景一般常见于电商购物，秒杀等购物场景。当用户下单之后，页面将会开始倒计时，用户需要在有效期内支付成功。

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000228.jpeg)

假设用户点击跳转到支付宝，但是其没有立刻支付，而是停留了很久，在订单最后一秒时间内完成了支付，但是这个时候订单早已因为时间到期而被自动取消。

这样就发生用户扣款已经成功，但是订单却是失败或关闭的场景的。

另外还有一种情况，用户在有效期内支付成功，但是因为网络、内部应用等问题，支付结果的异步通知过了很久才收到，这时内部订单的早因为时间到期而被取消。

### 3.2解决办法

**第一种解决办法，上送有效期给支付渠道。**

一般支付接口都会有一个支付有效期的字段，表明这笔支付最晚可以支付的时间。如果超时未支付，这笔支付将会被关闭。

![来自支付宝开发文档](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/project-design/20210423000237.jpeg)

当然一般情况下，如果未上送，这个字段内部一般会有个默认的有效期，比如 3 天，这个时间就比较长了。

所以当调用支付接口时，可以将订单剩余有效期传入支付接口。这样用户如果在超时时间内未完成支付，支付将会失败。

**第二种解决办法，内部发起退款。**

这个解决办法依然事后托底的解决办法，对于支付订单已关闭，但是支付却成功的情况，发起内部退款，将钱退给用户。

内部可以有个定时任务，定时扫描支付订单已关闭但是支付却成功的情况，然后发起退款指令。