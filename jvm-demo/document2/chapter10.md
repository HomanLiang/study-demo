[toc]



# JVM 面试题

## JVM 体系结构







## JVM 内存区域

### 1.哪些场景会产生OOM？怎么解决？

### 2.简述下对象的分配规则

### 3.栈上分配是什么意思

对象逃逸,TLAB

### 4.虚拟机为什么使用元空间替换了永久代？

### 5.什么是指针碰撞？什么是空闲列表？什么是TLAB？

### 6.Java堆内存是线程共享的吗？

### 7.一个Java对象占用多大内存

## JVM 垃圾收集

### 1.GC 的几种主要的收集方法：标记清除、标记整理、复制算法的原理与特点，各自的优劣势

### 2.为啥会有 Serial ，CMS, G1 等各式样的回收器，各自的优劣势是什么，为啥没有一个统一的万能的垃圾回收器

### 3.新生代为啥要设置成 Eden, S0,S1 这三个区，基于什么考虑呢

### 4.堆外内存不受 GC 控制，那该怎么释放呢

### 5.对象可回收，就一定会被回收吗？

### 6.什么是 SafePoint,什么是 Stop The World

进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为**「Stop The World」**。

在HotSpot中，有个数据结构（映射表）称为**「OopMap」**。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在**「特定的位置」**生成 OopMap，记录下栈上和寄存器里哪些位置是引用。

这些特定的位置主要在：

- 1.循环的末尾（非 counted 循环）
- 2.方法临返回前 / 调用方法的call指令后
- 3.可能抛异常的位置

这些位置就叫作**「安全点(safepoint)。」** 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。 

### 7.如何判断一个对象是否存活?(或者GC对象的判定方法)?

### 8.GC是什么？为什么要GC

### 9.你能保证GC执行吗？

不能，我只能通过手动执行`System.gc()`方法通知GC执行，但是他是否执行的未知的。

### 10.对象的引用类型有哪几种，分别介绍下

### 11.为什么要分代

因为在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间会相对较长，也有很多对象完全没必要遍历，比如大对象存活的时间更长，遍历下来发现不需要回收，这样更浪费时间。所以才有了分代，分治的思想，进行区域划分，把不同生命周期的对象放在不同的区域，不同的区域采取最适合他的垃圾回收方式进行回收。

### 12.分代垃圾回收是怎么工作的

### 13.GC日志分析

### 14.Minor GC与Full GC分别在什么时候发生

### 15.新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？

### 16.守护线程是什么？守护线程和非守护线程的区别是？守护线程的作用是？



## JVM 字节码







## JVM 类加载







## JVM 实战







## JVM 命令行工具







## JVM GUI 工具







## Java 应用故障诊断









