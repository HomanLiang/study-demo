[toc]



# JVM 体系结构

## 1. JVM 简介

### 1.1. 计算机体系结构

真实的计算机体系结构的核心部分包含：

- 指令集
- 计算单元（CPU）
- 寻址方式
- 寄存器
- 存储单元

### 1.2. JVM 体系结构简介

JVM 体系结构与计算机体系结构相似，它的核心部分包含：

- JVM 指令集
- 类加载器
- 执行引擎 - 相当于 JVM 的 CPU
- 内存区 - JVM 的存储
- 本地方法调用 - 调用 C/C++ 实现的本地方法

## 2. Hotspot 架构

Hotspot 是最流行的 JVM。

Java 虚拟机的主要组件，包括**类加载器**、**运行时数据区**和**执行引擎**。

Hotspot 虚拟机拥有一个架构，它支持强大特性和能力的基础平台，支持实现高性能和强大的可伸缩性的能力。举个例子，Hotspot 虚拟机 JIT 编译器生成动态的优化，换句话说，它们在 Java 应用执行期做出优化，为底层系统架构生成高性能的本地机器指令。另外，经过它的运行时环境和多线程垃圾回收成熟的进化和连续的设计， Hotspot 虚拟机在高可用计算系统上产出了高伸缩性。

![image-20210327113106657](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327113106.png)

### 2.1. Hotspot 关键组件

Java 虚拟机有三个组件关注着什么时候进行性能优化，堆空间是对象所存储的地方，这个区域被启动时选择的垃圾回收器管理，大部分调优选项与调整堆大小和根据你的情况选择最适当的垃圾收集器相关。即时编译器对性能也有很大的影响，但是使用新版本的 Java 虚拟机时很少需要调整。

![image-20210327113119627](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327113119.png)

### 2.2. 性能指标

Java 虚拟机的性能指标主要有两点：

- 停顿时间 - 响应延迟是指一个应用回应一个请求的速度有多快。对关注响应能力的应用来说，长暂停时间是不可接受的，重点是在短的时间周期内能做出响应。
  - 桌面 UI 响应事件的速度
  - 网站返回网页的速度
  - 数据查询返回的速度
- 吞吐量 - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。
  - 给定时间内完成事务的数量
  - 一小时内批处理程序完成的工作数量
  - 一小时内数据查询完成的数量



## 3.内存模型

**Java内存模型** 即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。

如果我们要想深入了解Java并发编程，就要先理解好Java内存模型。Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此Java1.5版本对其进行了重构，现在的Java8仍沿用了Java1.5的版本。

### 3.1.关于并发编程

在并发编程领域，有两个关键问题：线程之间的**通信**和**同步**。

**线程之间的通信**

线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种共享内存和消息传递。

在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。

在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是wait()和notify()。

**线程之间的同步**

同步是指程序用于控制不同线程之间操作发生相对顺序的机制。

在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。

在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

**Java的并发采用的是共享内存模型**

Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。

### 3.2.Java内存模型

上面讲到了Java线程之间的通信采用的是过共享内存模型，这里提到的共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyMzM3OTA0](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327161526.png)

从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

```
1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 
```

下面通过示意图来说明这两个步骤：

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyNzQ4NTUx](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327161558.png)

如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。

从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。

上面也说到了，Java内存模型只是一个抽象概念，那么它在Java中具体是怎么工作的呢？为了更好的理解上Java内存模型工作方式，下面就JVM对Java内存模型的实现、硬件内存模型及它们之间的桥接做详细介绍。

### 3.3.JVM对Java内存模型的实现

在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区，下图展示了Java内存模型在JVM中的逻辑视图：

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyODM3Njk3](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327161648.png)

JVM中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。

线程栈还包含了当前方法的所有本地变量信息。一个线程只能读取自己的线程栈，也就是说，线程中的本地变量对其它线程是不可见的。即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈中创建本地变量，因此，每个线程中的本地变量都会有自己的版本。

所有原始类型(boolean,byte,short,char,int,long,float,double)的本地变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。

堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。

下图展示了调用栈和本地变量都存储在栈区，对象都存储在堆区：

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyOTAzODE4](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327161711.png)

一个本地变量如果是原始类型，那么它会被完全存储到栈区。

一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。

对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。

对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。

Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。

堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。

下图展示了上面描述的过程:

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgyOTQ4NjAx](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327161748.png)

### 3.4.硬件内存架构

不管是什么内存模型，最终还是运行在计算机硬件上的，所以我们有必要了解计算机硬件内存架构，下图就简单描述了当代计算机硬件内存架构：

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgzMDEzNTcw](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327161826.png)

现代计算机一般都有2个以上CPU，而且每个CPU还有可能包含多个核心。因此，如果我们的应用是多线程的话，这些线程可能会在各个CPU核心中并行运行。

在CPU内部有一组CPU寄存器，也就是CPU的储存器。CPU操作寄存器的速度要比操作计算机主存快的多。在主存和CPU寄存器之间还存在一个CPU缓存，CPU操作CPU缓存的速度快于主存但慢于CPU寄存器。某些CPU可能有多个缓存层（一级缓存和二级缓存）。计算机的主存也称作RAM，所有的CPU都能够访问主存，而且主存比上面提到的缓存和寄存器大很多。

当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存。

### 3.5.Java内存模型和硬件架构之间的桥接

正如上面讲到的，Java内存模型和硬件内存架构并不一致。硬件内存架构中并没有区分栈和堆，从硬件上看，不管是栈还是堆，大部分数据都会存到主存中，当然一部分栈和堆的数据也有可能会存到CPU寄存器中，如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgzMTQ0OTk1](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327161907.png)

对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要的两个问题是：

```
1. 共享对象对各个线程的可见性
2. 共享对象的竞争现象
```

**共享对象的可见性**

多个线程同时操作同一个共享对象时，如果没有合理的使用volatile和synchronization关键字，一个线程对共享对象的更新有可能导致其它线程不可见。

想象一下我们的共享对象存储在主存，一个CPU中的线程读取主存数据到CPU缓存，然后对共享对象做了更改，但CPU缓存中的更改后的对象还没有flush到主存，此时线程对共享对象的更改对其它CPU中的线程是不可见的。最终就是每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的CPU缓存中。

下图展示了上面描述的过程。左边CPU中运行的线程从主存中拷贝共享对象obj到它的CPU缓存，把对象obj的count变量改为2。但这个变更对运行在右边CPU中的线程不可见，因为这个更改还没有flush到主存中：

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgzMjE4NjUx](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327161943.png)

要解决共享对象可见性这个问题，我们可以使用java volatile关键字。 Java’s volatile keyword. volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的。

**竞争现象**

如果多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象。

如下图所示，线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。

如果这两个加1操作是串行执行的，那么Obj.count变量便会在原始值上加2，最终主存中的Obj.count的值会是3。然而下图中两个加1操作是并行的，不管是线程A还是线程B先flush计算结果到主存，最终主存中的Obj.count只会增加1次变成2，尽管一共有两次加1操作。

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIxMTgzMjUxODcw](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327162022.png)

### 3.6.支撑Java内存模型的基础原理

**指令重排序**

在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。

- 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

**数据依赖性**

如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。
编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。

**as-if-serial**

不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。

**内存屏障（Memory Barrier ）**

上面讲到了，通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：

- 保证特定操作的执行顺序。

- 影响某些数据（或则是某条指令的执行结果）的内存可见性。

编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。

Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。

这和java有什么关系？上面java内存模型中讲到的volatile是基于Memory Barrier实现的。

如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，并在读这个字段之前插入一个Read-Barrier指令。这意味着，如果写入一个volatile变量，就可以保证：

- 一个线程写入变量a后，任何线程访问该变量都会拿到最新值。
- 在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。

**appens-before**

从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。

在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。

与程序员密切相关的happens-before规则如下：

- 程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。
- 监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。
- volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
- 传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。

注意：两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。

### 3.7.Java 执行过程中的内存模型

#### 3.7.1.前言

**本文的主要工作**：尝试以时间顺序追踪一遍 Java 执行的整个过程，以及展示 JVM 中内存模型的相应变化。

**本文的主要目的**：希望能够通过 Java 执行过程的冰山一角，增进对编程语言工作原理的理解。

以下面这段代码为例，追踪它的执行过程：

```java
public class Car {
    private int speed;

    public void setSpeed(int speed) {
        this.speed = speed;
    }

    public void getSpeed() {
        System.out.println(speed);
    }

    public static void main(String[] args) {
        Car car = new Car();
        car.setSpeed(3);
        car.getSpeed();
    }
}
```

#### 3.7.2.执行过程

接下来是具体的执行过程，总共包含五个步骤：编译、加载、执行 main 方法、执行成员方法、方法返回。

**Step1**：编译

首先，在我们完成上述这段源码之后，要想让程序跑起来，我们需要将其编译成为字节码文件。字节码是一种跨平台的JVM机器语言，它能够被JVM所解析，而无关底层的操作系统。

**Step2**：加载

当代码需要被调用时，JVM 会加载目标字节码至方法区，并转化为方法区的运行时数据结构，这里的加载过程是通过类加载器完成的。然后内存中（不一定是堆）会生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据结构的访问入口。

![1039974-20210131182548437-1656820007](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327162901.png)

**Step3**：执行 main 方法

main 方法可以通过 java.lang.Class 对象进行调用，参考如下代码：

```java
Method method = targetClass.getDeclareMethod("main", String[].class);
method.invoke(null, (Object) new String[0]);
```

之后 PC 寄存器将会指向方法区中的 main 函数地址，线程栈中会生成对应的栈桢，其主要用于存放当前方法的局部变量表、操作栈、以及方法返回地址。接下来，PC 寄存器向后地址偏移，执行引擎开始执行 main 方法体。当语句 Car car = new Car() 执行完毕，栈桢与堆中的相应变化如下：

![1039974-20210131182615986-268099081](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327162909.png)

**Step4**：执行成员方法

对象 car 的 setSpeed 方法调用过程和 main 类似，通过索引 car 的成员方法地址，PC寄存器将指向方法区中的 setSpeed 函数地址，同时线程栈中将产生新的栈桢，其中的方法返回地址用于保存原有 PC 地址偏移。当赋值语句 this.speed = speed 执行完毕，栈桢与堆中发生的相应变化如下：

![1039974-20210131182635313-809201412](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327162915.png)

**Step5**：方法返回

随着 setSpeed 方法的执行结束，Stack 中的相应栈桢出栈，栈顶指针重新指向 main 栈桢。同时 PC 寄存器将根据方法返回地址进行还原，从而继续执行 main 的方法体。当 main 方法也执行完毕出栈后，主线程与虚拟机实例销亡，程序结束。

#### 3.7.3.杂谈

虚拟机或某一门程序语言，作为一种底层实现，可以满足上层用户的绝大部分需求，但是需求是与时俱进的，总有一天用户需要编写自己的底层实现，比如组件、框架、一门新语言。这时需要打开原有的规范，先破坏它，再重建它，从而定义自己的规范。这也许是我们需要探究底层的缘由之一吧。