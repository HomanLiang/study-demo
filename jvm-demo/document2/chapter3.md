[toc]



# JVM 垃圾收集

> 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。**垃圾回收主要是针对 Java 堆和方法区进行**。

## 1.什么是垃圾回收？

垃圾回收（Garbage Collection，GC）：就是释放垃圾占用的空间，防止内存泄露。对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。

## 2. 垃圾在哪儿？

![640 (3)](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210328000119.webp)

上图可以看到程序计数器、虚拟机栈、本地方法栈都是伴随着线程而生死，这些区域不需要进行 GC。

而方法区/元空间在 1.8 之后就直接放到本地内存了，假设总内存 2G，JVM 被分配内存 100M， 理论上元空间可以分配 2G-100M = 1.9G，空间还是足够的，所以这块区域也不用管。

所以就只剩下**堆**了，java 对象实例和数组都是在**堆**上分配的，所以垃圾回收器重点照顾**堆**。

## 3. 怎么发现它？

在发生 GC 的时候，Jvm 是怎么判断堆中的对象实例是不是垃圾呢？

这里有两种方式：

### 3.1. 引用计数算法

给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

```
public class ReferenceCountingGC {
    public Object instance = null;

    public static void main(String[] args) {
        ReferenceCountingGC objectA = new ReferenceCountingGC();
        ReferenceCountingGC objectB = new ReferenceCountingGC();
        objectA.instance = objectB;
        objectB.instance = objectA;
        objectA = null;
        objectB = null;
    }
}
```

因为循环引用的存在，所以 **Java 虚拟机不适用引用计数算法**。

### 3.2. 可达性分析算法

通过 **GC Roots** 作为起始点进行搜索，JVM 将能够到达到的对象视为**存活**，不可达的对象视为**死亡**。

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d726f6f742e706e67](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/java-core-demo/20210327112410.png)

**可作为 GC Roots 的对象**包括下面几种：

- **虚拟机栈中引用的对象**

  如下代码所示，a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 **GC Root** 的作用，a 与原来指向的实例 **new Test()** 断开了连接，所以对象会被回收。

  ```
  public class Test {
      public static  void main(String[] args) {
  	Test a = new Test();
  	a = null;
      }
  }
  ```

- **本地方法栈中JNI引用的对象（Native 方法）**

  当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。

  ![640](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327232540.webp)

  ```
  JNIEXPORT void JNICALL Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative(JNIEnv *env, jobject instance，jstring jmsg) {
  ...
     // 缓存String的class
     jclass jc = (*env)->FindClass(env, STRING_PATH);
  }
  ```

  如上代码所示，当 java 调用以上本地方法时，jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用，因此只会在此本地方法执行完成后才会被释放。

- **方法区中，类静态属性引用的对象**

  如下代码所示，当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!

  ```
  public  class Test {
      public  static Test s;
      public static  void main(String[] args) {
  	Test a = new Test();
  	a.s = new Test();
  	a = null;
      }
  }
  ```

- **方法区中，常量引用的对象**

  如下代码所示，常量 s 指向的对象并不会因为 a 指向的对象被回收而回收

  ```
  public  class Test {
  	public  static  final Test s = new Test();
          public static void main(String[] args) {
  	    Test a = new Test();
  	    a = null;
          }
  }
  ```


### 3.3. 引用类型

无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。

Java 具有四种强度不同的引用类型。

#### 3.3.1 强引用

**被强引用（Strong Reference）关联的对象不会被垃圾收集器回收。**

强引用：使用 `new` 一个新对象的方式来创建强引用。

```
Object obj = new Object();
```

#### 3.3.2 软引用

**被软引用（Soft Reference）关联的对象，只有在内存不够的情况下才会被回收。**

软引用：使用 `SoftReference` 类来创建软引用。

```
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null; // 使对象只被软引用关联
```

#### 3.3.3 弱引用

**被弱引用（Weak Reference）关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。**

使用 `WeakReference` 类来实现弱引用。

```
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

`WeakHashMap` 的 `Entry` 继承自 `WeakReference`，主要用来实现缓存。

```
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V>
```

Tomcat 中的 `ConcurrentCache` 就使用了 `WeakHashMap` 来实现缓存功能。`ConcurrentCache` 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 `ConcurrentHashMap` 实现，longterm 使用 `WeakHashMap`，保证了不常使用的对象容易被回收。

```
public final class ConcurrentCache<K, V> {

    private final int size;

    private final Map<K, V> eden;

    private final Map<K, V> longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap<>(size);
        this.longterm = new WeakHashMap<>(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() >= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
```

#### 3.3.4 虚引用

又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。

**为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。**

使用 `PhantomReference` 来实现虚引用。

```
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

#### 3.3.5 为什么定义这些引用？

个人理解，其实就是给对象加一种中间态，让一个对象不只有`引用和非引用`两种情况，还可以描述一些“食之无味弃之可惜”的对象。比如说：当内存空间足时，则能保存在内存中，如果内存空间在进行垃圾回收之后还不够时，`才对这些对象进行回收`。

### 3.4. 方法区的回收

因为方法区主要存放永久代对象，而永久代对象的回收率比年轻代差很多，因此在方法区上进行回收性价比不高。

主要是对常量池的回收和对类的卸载。

类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

可以通过 `-Xnoclassgc` 参数来控制是否对类进行卸载。

在大量使用反射、动态代理、CGLib 等字节码框架、动态生成 JSP 以及 OSGi 这类频繁自定义 `ClassLoader` 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。

## 4.生存还是死亡？

要真正宣告一个对象死亡，至少要经历两次标记过程和一次筛选。

一张图带你看明白：

![640 (4)](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210328000610.webp)

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
  
如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中。并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果有一个对象在finalize()方法中执行缓慢，或者发生死循环，将可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。
  
finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象这个时候，未被重新引用，那它基本上就真的被回收了。

### 4.1. finalize()

`finalize()` 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此**最好不要使用 `finalize()`**。

当一个对象可被回收时，如果需要执行该对象的 `finalize()` 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。

## 5. 垃圾收集算法

### 5.1. 垃圾收集性能

垃圾收集器的性能指标主要有两点：

- **停顿时间** - 停顿时间是因为 GC 而导致程序不能工作的时间长度。
- **吞吐量** - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。

### 5.2. 标记 - 清除（Mark-Sweep）

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d6d61726b2d73776565702e6a7067](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/java-core-demo/20210327112457.jpg)

将需要回收的对象进行标记，然后清理掉被标记的对象。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

### 5.3. 标记 - 整理（Mark-Compact）

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d6d61726b2d636f6d706163742e6a7067](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/java-core-demo/20210327112509.jpg)

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销（每进一次垃圾清除都要频繁地移动存活的对象）。

### 5.4. 复制（Copying）

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d636f7079696e672e6a7067](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/java-core-demo/20210327112521.jpg)

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都**采用这种收集算法来回收年轻代**，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1（可以通过参数 `-XX:SurvivorRatio`来调整比例），保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

### 5.5. 分代收集

分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收集呢，来看一下对象的分配有啥规律

![640](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327233108.webp)

*如图示：**纵轴代表已分配的字节，而横轴代表程序运行时间*

由图可知，大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据**对象存活周期的不同**将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。

![640](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327233158.png)

*画外音：思考一下，新生代为啥要分这么多区？*

那么分代垃圾收集是怎么工作的呢，我们一起来看看

#### 5.5.1.分代收集工作原理

**1、对象在新生代的分配与回收**

由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区

![640 (1)](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327233209.webp)

当 Eden 区将满时，触发 Minor GC

![640 (1)](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327233221.png)

我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间,动图如下

![640](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327233230.gif)

当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。

![640 (1)](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327233243.gif)

若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是**复制算法**，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。

**2、对象何时晋升老年代**

- 当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代

  ![640 (2)](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327233342.gif)

  如图示：年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！

- 大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.

- 还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。

**3、空间分配担保**

在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。

**4、Stop The World**

如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。

什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。

![640 (2)](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327233355.webp)

*画外音：为啥在垃圾收集期间其他工作线程会被挂起？想象一下，你一边在收垃圾，另外一群人一边丢垃圾，垃圾能收拾干净吗。*

一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理**整个堆**中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。

现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了**尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC**。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。

由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：

- 循环的末尾
- 方法返回前
- 调用方法的 call 之后
- 抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。

#### 5.5.4.JVM 参数

这里顺便提一下，JVM 允许对堆空间大小、各代空间大小进行设置，以调整 JVM GC。

| 配置                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| `-Xss`              | 虚拟机栈大小。                                               |
| `-Xms`              | 堆空间初始值。                                               |
| `-Xmx`              | 堆空间最大值。                                               |
| `-Xmn`              | 新生代空间大小。                                             |
| `-XX:NewSize`       | 新生代空间初始值。                                           |
| `-XX:MaxNewSize`    | 新生代空间最大值。                                           |
| `-XX:NewRatio`      | 新生代与年老代的比例。默认为 2，意味着老年代是新生代的 2 倍。 |
| `-XX:SurvivorRatio` | 新生代中调整 eden 区与 survivor 区的比例，默认为 8。即 `eden` 区为 80% 的大小，两个 `survivor` 分别为 10% 的大小。 |
| `-XX:PermSize`      | 永久代空间的初始值。                                         |
| `-XX:MaxPermSize`   | 永久代空间的最大值。                                         |

## 6. 垃圾收集器

### 6.1.几个概念

#### 6.1.1.吞吐量

CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。

比如说虚拟机总运行了 100 分钟，用户代码时间 99 分钟，垃圾回收时间 1 分钟，那么吞吐量就是 99%。

#### 6.1.2.STW

全称 Stop-The-World，即在 GC 期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。

为什么需要 STW 呢？

在 java 程序中引用关系是不断会变化的，那么就会有很多种情况来导致垃圾标识出错。

想想一下如果一个对象 A 当前是个垃圾，GC 把它标记为垃圾，但是在清除前又有其他引用指向了 A，那么此刻又不是垃圾了。

那么，如果没有 STW 的话，就要去无限维护这种关系来去采集正确的信息，显然是不可取的。

#### 6.1.3.安全点

从线程角度看，安全点可以理解成是在代码执行过程中的一些**特殊位置**，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的。

比如：**方法调用**、**循环跳转**、**异常跳转**等这些地方才会产生安全点。

如果有需要，可以在这个位置暂停，比如发生 GC 时，需要暂停所有活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待 GC 结束。

#### 6.1.4.串行、并行

串行：是指垃圾回收线程在进行垃圾回收工作，此时用户线程处于等待状态。

并行：是指用户线程和多条垃圾回收线程分别在不同 CPU 上同时工作。

### 6.2.收集器

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d6f766572766965772e6a7067](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/java-core-demo/20210327112541.jpg)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

注：G1 垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。

### 6.3. 串行收集器

串行收集器（Serial）是最基本、发展历史最悠久的收集器。

串行收集器是 **`client` 模式下的默认收集器配置**。因为在客户端模式下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的年轻代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。

**串行收集器采用单线程 stop-the-world 的方式进行收集**。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，**采用单线程方式回收空间并整理内存**。

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d73657269616c2e6a7067](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/java-core-demo/20210327112548.jpg)

单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核 CPU 的场合。

特点：1、采用复制算法  2、单线程收集器  3、效率会比较慢，但是因为是单线程，所以消耗内存小

#### 6.3.1. Serial 收集器

> 开启选项：`-XX:+UseSerialGC`
>
> 打开此开关后，使用 **Serial** + **Serial Old** 收集器组合来进行内存回收。

#### 6.3.2.Serial Old 收集器

Serial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

特点：1、标记-整理算法 2、单线程 3、老年代工作

### 6.4. 并行收集器

> 开启选项：`-XX:+UseParallelGC`
>
> 打开此开关后，使用 **Parallel Scavenge** + **Serial Old** 收集器组合来进行内存回收。
>
> 开启选项：`-XX:+UseParallelOldGC`
>
> 打开此开关后，使用 **Parallel Scavenge** + **Parallel Old** 收集器组合来进行内存回收。

其他收集器都是以关注停顿时间为目标，而**并行收集器是以关注吞吐量（Throughput）为目标的垃圾收集器**。

- 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；
- 而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

```
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
```

**并行收集器是 server 模式下的默认收集器。**

并行收集器与串行收集器工作模式相似，都是 stop-the-world 方式，只是暂停时并行地进行垃圾收集。**并行收集器年轻代采用复制算法，老年代采用标记-整理**，在回收的同时还会对内存进行压缩。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。

**在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 收集器 + Parallel Old 收集器。**

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d706172616c6c656c2e6a7067](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/java-core-demo/20210327112608.jpg)

#### 6.4.1. Parallel Scavenge 收集器

Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是：

- `-XX:MaxGCPauseMillis` - 控制最大垃圾收集停顿时间，收集器将尽可能保证内存回收时间不超过设定值。
- `-XX:GCTimeRatio` - 直接设置吞吐量大小的（值为大于 0 且小于 100 的整数）。

缩短停顿时间是以牺牲吞吐量和年轻代空间来换取的：年轻代空间变小，垃圾回收变得频繁，导致吞吐量下降。

Parallel Scavenge 收集器还提供了一个参数 `-XX:+UseAdaptiveSizePolicy`，这是一个开关参数，打开参数后，就不需要手工指定年轻代的大小（`-Xmn`）、Eden 和 Survivor 区的比例（`-XX:SurvivorRatio`）、晋升老年代对象年龄（`-XX:PretenureSizeThreshold`）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。

特点：1、采用复制算法 2、多线程收集器 3、吞吐量优先

#### 6.4.2.Parallel Old 收集器

是 Parallel Scavenge 收集器的老年代版本，使用**多线程和 “标记-整理” 算法**。

### 6.5. 并发标记清除收集器

> 开启选项：`-XX:+UseConcMarkSweepGC`
>
> 打开此开关后，使用 **CMS** + **ParNew** + **Serial Old** 收集器组合来进行内存回收。

并发标记清除收集器是以获取最短停顿时间为目标。

开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 `Concurrent Mode Failure` ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。

#### 6.5.1. CMS 收集器

**CMS 收集器是一种以获取最短停顿时间为目标的收集器。**

CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。

##### 6.5.1.1.CMS 回收机制

CMS 收集器运行步骤如下：

1. **初始标记**：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
2. **并发标记**：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
3. **重新标记**：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
4. **并发清除**：回收在标记阶段被鉴定为不可达的对象。不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d636d732e6a7067](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/java-core-demo/20210327112624.jpg)

##### 6.5.1.2.CMS 回收年轻代详细步骤

**（1）堆空间被分割为三块空间**

年轻代分割成一个 Eden 区和两个 Survivor 区。年老代一个连续的空间。就地完成对象收集。除非有 FullGC 否则不会压缩。

**（2）CMS 年轻代垃圾收集如何工作**

年轻代被标为浅绿色，年老代被标记为蓝色。如果你的应用已经运行了一段时间，CMS 的堆看起来应该是这个样子。对象分散在年老代区域里。

使用 CMS，年老代对象就地释放。它们不会被来回移动。这个空间不会被压缩除非发生 FullGC。

**（3）年轻代收集**

从 Eden 和 Survivor 区复制活跃对象到另一个 Survivor 区。所有达到他们的年龄阈值的对象会晋升到年老代。

**（4）年轻代回收之后**

一次年轻代垃圾收集之后，Eden 区和其中一个 Survivor 区被清空。

最近晋升的对象以深蓝色显示在上图中，绿色的对象是年轻代幸免的还没有晋升到老年代对象。

##### 3.3.1.3.CMS 回收年老代详细步骤

**（1）CMS 的年老代收集**

发生两次 stop the world 事件：初始标记和重新标记。当年老代达到特定的占用比例时，CMS 开始执行。

- 初始标记是一个短暂暂停的、可达对象被标记的阶段。
- 并发标记寻找活跃对象在应用连续执行时。
- 最后，在重新标记阶段，寻找在之前并发标记阶段中丢失的对象。

**（2）年老代收集-并发清除**

在之前阶段没有被标记的对象会被就地释放。不进行压缩操作。

 **注意：**未被标记的对象等于死亡对象

**（3）年老代收集-清除之后**

清除阶段之后，你可以看到大量内存被释放。你还可以注意到没有进行压缩操作。

最后，CMS 收集器会再次进入重新设置阶段，等待下一次垃圾收集时机的到来。

##### 6.5.1.4.CMS 特点

CMS 收集器具有以下缺点：

- 并发收集 - 并发指的是用户线程和 GC 线程同时运行。

- 吞吐量低 - 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。

- 无法处理浮动垃圾 - 可能出现  `Concurrent Mode Failure`。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。

  - 可以使用 `-XX:CMSInitiatingOccupancyFraction` 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 `Concurrent Mode Failure`，这时虚拟机将临时启用 Serial Old 收集器来替代 CMS 收集器。

- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

  - 可以使用 `-XX:+UseCMSCompactAtFullCollection` ，用于在 CMS 收集器要进行 Full GC 时开启内存碎片的合并整理，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间不得不变长了。
  - 可以使用 `-XX:CMSFullGCsBeforeCompaction` ，用于设置执行多少次不压缩的 Full GC 后，来一次带压缩的（默认为 0，表示每次进入 Full GC 时都要进行碎片整理）。

#### 6.5.2.ParNew 收集器

> 开启选项：`-XX:+UseParNewGC`

ParNew 收集器其实是 Serial 收集器的多线程版本。

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d7061722d6e65772e6a7067](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/java-core-demo/20210327112751.jpg)

是 Server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。

ParNew 收集器也是使用 `-XX:+UseConcMarkSweepGC` 后的默认年轻代收集器。

ParNew 收集器默认开启的线程数量与 CPU 数量相同，可以使用 -`XX:ParallelGCThreads` 参数来设置线程数。

### 6.7. G1 收集器

> 开启选项：`-XX:+UseG1GC`

前面提到的垃圾收集器一般策略是关注吞吐量或停顿时间。而 **G1 是一种兼顾吞吐量和停顿时间的 GC 收集器**。G1 是 Oracle JDK9 以后的默认 GC 收集器。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。

G1 最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷。

#### 6.7.1. 分代和分区

旧的垃圾收集器一般采取分代收集，Java 堆被分为年轻代、老年代和永久代。收集的范围都是整个年轻代或者整个老年代。

G1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。G1 可以直接对年轻代和老年代一起回收。

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d67312d686561702d616c6c6f636174696f6e2e706e67](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327112839.png)

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

#### 6.7.2.G1 回收机制

![687474703a2f2f64756e77752e746573742e757063646e2e6e65742f63732f6a6176612f6a617661636f72652f6a766d2f6a766d2d67632d67312e6a7067](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210327112854.jpg)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

1. **初始标记**
2. **并发标记**
3. **最终标记** - 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
4. **筛选回收** - 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

#### 6.7.3.G1 回收年轻代详细步骤

**（1）G1 初始堆空间**

堆空间是一个被分成许多固定大小区域的内存块。

 Java 虚拟机启动时选定区域大小。Java 虚拟机通常会指定 2000 个左右的大小相等、每个大小范围在 1 到 32M 的区域。

**（2）G1 堆空间分配**

实际上，这些区域被映射成 Eden、Survivor、年老代空间的逻辑表述形式。

图片中的颜色表明了哪个区域被关联上什么角色。活跃对象从一个区域疏散（复制、移动）到另一个区域。区域被设计为并行的方式收集，可以暂停或者不暂停所有的其它用户线程。

明显的区域可以被分配成 Eden、Survivor、Old 区域。另外，有第四种类型的区域叫做*极大区域(Humongous regions)*。这些区域被设计成保持标准区域大小的 50%或者更大的对象。它们被保存在一个连续的区域集合里。最后，最后一个类型的区域就是堆空间里没有使用的区域。

**注意：**写作此文章时，收集极大对象时还没有被优化。因此，你应该避免创建这个大小的对象。

**（3）G1 的年轻代**

堆空间被分割成大约 2000 个区域。最小 1M，最大 32M，蓝色区域保持年老代对象，绿色区域保持年轻代对象。

**注意：**区域没有必要像旧的收集器一样是保持连续的。

**（4）G1 的年轻代收集**

活跃对象会被疏散（复制、移动）到一个或多个 survivor 区域。如果达到晋升总阈值，对象会晋升到年老代区域。

这是一个 stop the world 暂停。为下一次年轻代垃圾回收计算 Eden 和 Survivor 的大小。保留审计信息有助于计算大小。类似目标暂停时间的事情会被考虑在内。

这个方法使重调区域大小变得很容易，按需把它们调大或调小。

**（5）G1 年轻代回收的尾声**

活跃对象被疏散到 Survivor 或者年老代区域。

最近晋升的对象显示为深蓝色。Survivor 区域显示为绿色。

关于 G1 的年轻代回收做以下总结：

- 堆空间是一块单独的内存空间被分割成多个区域。
- 年轻代内存是由一组非连续的区域组成。这使得需要重调大小变得容易。
- 年轻代垃圾回收是 stop the world 事件，所有应用线程都会因此操作暂停。
- 年轻代垃圾收集使用多线程并行回收。
- 活跃对象被复制到新的 Survivor 区或者年老代区域。

#### 6.7.4.G1 回收年老代详细步骤

**（1）初始标记阶段**

年轻代垃圾收集肩负着活跃对象初始标记的任务。在日志文件中被标为*GC pause (young)(inital-mark)*

**（2）并发标记阶段**

如果发现空区域(“X”标示的)，在重新标记阶段它们会被马上清除掉。当然，决定活性的审计信息也在此时被计算。

**（3）重新标记阶段**

空的区域被清除和回收掉。所有区域的活性在此时计算。

**（4）复制/清理阶段**

G1 选择活性最低的区域，这些区域能够以最快的速度回收。然后这些区域会在年轻代垃圾回收过程中被回收。在日志中被指示为*[GC pause (mixed)]*。所以年轻代和年老代在同一时间被回收。

**（5）复制/清理阶段之后**

被选择的区域已经被回收和压缩到图中显示的深蓝色区和深绿色区中。

### 6.8. 总结

| 收集器                | 串行/并行/并发 | 年轻代/老年代   | 收集算法             | 目标         | 适用场景                                      |
| --------------------- | -------------- | --------------- | -------------------- | ------------ | --------------------------------------------- |
| **Serial**            | 串行           | 年轻代          | 复制                 | 响应速度优先 | 单 CPU 环境下的 Client 模式                   |
| **Serial Old**        | 串行           | 老年代          | 标记-整理            | 响应速度优先 | 单 CPU 环境下的 Client 模式、CMS 的后备预案   |
| **ParNew**            | 串行 + 并行    | 年轻代          | 复制算法             | 响应速度优先 | 多 CPU 环境时在 Server 模式下与 CMS 配合      |
| **Parallel Scavenge** | 串行 + 并行    | 年轻代          | 复制算法             | 吞吐量优先   | 在后台运算而不需要太多交互的任务              |
| **Parallel Old**      | 串行 + 并行    | 老年代          | 标记-整理            | 吞吐量优先   | 在后台运算而不需要太多交互的任务              |
| **CMS**               | 并行 + 并发    | 老年代          | 标记-清除            | 响应速度优先 | 集中在互联网站或 B/S 系统服务端上的 Java 应用 |
| **G1**                | 并行 + 并发    | 年轻代 + 老年代 | 标记-整理 + 复制算法 | 响应速度优先 | 面向服务端应用，将来替换 CMS                  |

## 7. 内存分配与回收策略

对象的内存分配，也就是在堆上分配。主要分配在年轻代的 Eden 区上，少数情况下也可能直接分配在老年代中。

**堆空间的结构：**

![640 (2)](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210328002119.png)

### 7.1.Eden 区

研究表明，有将近 98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配。

当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。

通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。

### 7.2.Survivor 区

Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，Survivor 又分为 2 个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。

**问题 1:为什么需要 Survivor？**

如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实或许第二次，第三次就需要被清除。

这时候移入老年区，很明显不是一个明智的决定。

所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少老年代 GC 的发生。Survivor 的预筛选保证，只有经历 15 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。

**问题 2:为什么需要 From 和 To 两个呢？**

这种机制最大的好处就是可以解决**内存碎片化**，整个过程中，永远有一个 Survivor 区是空的，另一个非空的 Survivor 区是无碎片的。

假设只有一个 Survivor 区。

Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。

那么问题来了，这时候我们怎么清除它们？

在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。

因为 Survivor 有 2 个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，To 区 到 From 区 ，以此反复。

### 7.3.Old 区

老年代占据着 2/3 的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。

由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以在这里老年代采用的是标记整理算法。

**下面三种情况也会直接进入老年代：**

#### 7.3.1.大对象

大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及 2 个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，需要注意。

#### 7.3.2.长期存活对象

虚拟机给每个对象定义了一个对象年龄 Age 计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加 1 岁。当年龄增加到 15 岁时，这时候就会被转移到老年代。

#### 7.3.3.动态对象年龄

虚拟机并不重视要求对象年龄必须到 15 岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区。

### 7.4.空间分配担保

在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。

如果条件成立的话，Minor GC 是可以确保安全的。

如果不成立，则虚拟机会查看 HandlePromotionFailure 设置是否担保失败，如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。

如果大于，尝试进行一次 Minor GC。

如果小于或者 HandlePromotionFailure 不允许，则进行一次 Full GC。

### 7.5. Minor GC

**当 `Eden` 区空间不足时，触发 Minor GC**。

**Minor GC 发生在年轻代上**，因为年轻代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。

Minor GC 工作流程：

1. Java 应用不断创建对象，通常都是分配在 `Eden` 区域，当其空间不足时（达到设定的阈值），触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。
2. 经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件。这时候，另外一个 Survivor 区域则会成为 `To` 区域，Eden 区域的存活对象和 `From` 区域对象，都会被复制到 `To` 区域，并且存活的年龄计数会被加 1。
3. 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过 `-XX:MaxTenuringThreshold` 参数指定。

### 7.6. Full GC

**Full GC 发生在老年代上**，老年代对象和年轻代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。

#### 7.6.1.内存分配策略

**（一）对象优先在 Eden 分配**

大多数情况下，对象在年轻代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。

**（二）大对象直接进入老年代**

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

`-XX:PretenureSizeThreshold`，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。

**（三）长期存活的对象进入老年代**

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

`-XX:MaxTenuringThreshold` 用来定义年龄的阈值。

**（四）动态对象年龄判定**

虚拟机并不是永远地要求对象的年龄必须达到 `MaxTenuringThreshold` 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 `MaxTenuringThreshold` 中要求的年龄。

**（五）空间分配担保**

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于年轻代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 `HandlePromotionFailure` 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 `HandlePromotionFailure` 设置不允许冒险，那这时也要改为进行一次 Full GC。

#### 7.6.2.Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

**（1）调用 `System.gc()`**

此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 `-XX:DisableExplicitGC` 来禁止 RMI 调用 `System.gc()`。

**（2）老年代空间不足**

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 `java.lang.OutOfMemoryError: Java heap space`。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在年轻代多存活一段时间以及不要创建过大的对象及数组。

**（3）方法区空间不足**

JVM 规范中运行时数据区域中的**方法区**，在 HotSpot 虚拟机中又被习惯称为**永久代**，永久代中存放的是类的描述信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出 `java.lang.OutOfMemoryError: PermGen space` 错误。为避免永久代占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。

**（4）Minor GC 的平均晋升空间大小大于老年代可用空间**

如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。

**（5）对象大小大于 To 区和老年代的可用内存**

由 `Eden` 区、`From` 区向 `To` 区复制时，对象大小大于 To 区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

#### 7.6.3.在什么情况下，GC会对程序产生影响？

不管YGC还是FGC，都会造成一定程度的程序卡顿（即Stop The World问题：GC线程开始工作，其他工作线程被挂起），即使采用ParNew、CMS或者G1这些更先进的垃圾回收算法，也只是在减少卡顿时间，而并不能完全消除卡顿。

那到底什么情况下，GC会对程序产生影响呢？根据严重程度从高到底，我认为包括以下4种情况：

- FGC过于频繁：FGC通常是比较慢的，少则几百毫秒，多则几秒，正常情况FGC每隔几个小时甚至几天才执行一次，对系统的影响还能接受。但是，一旦出现FGC频繁（比如几十分钟就会执行一次），这种肯定是存在问题的，它会导致工作线程频繁被停止，让系统看起来一直有卡顿现象，也会使得程序的整体性能变差。
- YGC耗时过长：一般来说，YGC的总耗时在几十或者上百毫秒是比较正常的，虽然会引起系统卡顿几毫秒或者几十毫秒，这种情况几乎对用户无感知，对程序的影响可以忽略不计。但是如果YGC耗时达到了1秒甚至几秒（都快赶上FGC的耗时了），那卡顿时间就会增大，加上YGC本身比较频繁，就会导致比较多的服务超时问题。
- FGC耗时过长：FGC耗时增加，卡顿时间也会随之增加，尤其对于高并发服务，可能导致FGC期间比较多的超时问题，可用性降低，这种也需要关注。
- YGC过于频繁：即使YGC不会引起服务超时，但是YGC过于频繁也会降低服务的整体性能，对于高并发服务也是需要关注的。

其中，「FGC过于频繁」和「YGC耗时过长」，这两种情况属于比较典型的GC问题，大概率会对程序的服务质量产生影响。剩余两种情况的严重程度低一些，但是对于高并发或者高可用的程序也需要关注。



## X.面试题

### X.1.守护线程是什么？守护线程和非守护线程的区别是？守护线程的作用是？

**「守护线程」**是区别于用户线程哈，**「用户线程」**即我们手动创建的线程，而守护线程是程序运行的时候在后台提供一种**「通用服务的线程」**。垃圾回收线程就是典型的守护线程。

**「守护线程和非守护线程的区别是？」** 我们通过例子来看吧~

```

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-> {
                while (true) {
                    try {
                        Thread.sleep(1000);
                        System.out.println("我是子线程(用户线程.I am running");
                    } catch (Exception e) {
                    }
                }
        });
        //标记为守护线程
        t1.setDaemon(true);
        //启动线程
        t1.start();

        Thread.sleep(3000);
        System.out.println("主线程执行完毕...");
    }
```

运行结果：

![图片](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210328114000.webp)

可以发现标记为守护线程后，**「主线程销毁停止，守护线程一起销毁」**。我们再看下，去掉 t1.setDaemon(true)守护标记的效果：

```
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-> {
                while (true) {
                    try {
                        Thread.sleep(1000);
                        System.out.println("我是子线程(用户线程.I am running");
                    } catch (Exception e) {
                    }
                }
        });
        //启动线程
        t1.start();

        Thread.sleep(3000);
        System.out.println("主线程执行完毕...");
    }
```

![图片](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210328114007.png)

所以，当主线程退出时，JVM 也跟着退出运行，守护线程同时也会被回收，即使是死循环。如果是用户线程，它会一直停在死循环跑。这就是**「守护线程和非守护线程的区别」**啦。

守护线程拥有**「自动结束自己生命周期的特性」**，非守护线程却没有。如果垃圾回收线程是非守护线程，当JVM 要退出时，由于垃圾回收线程还在运行着，导致程序无法退出，这就很尴尬。这就是**「为什么垃圾回收线程需要是守护线程啦」**。

### X.2.Java 对象不使用时，为什么要赋值为 null？

#### X.2.1.前言

许多Java开发者都曾听说过 **不使用的对象应手动赋值为null** 这句话，而且好多开发者一直信奉着这句话；问其原因，大都是回答“**有利于GC更早回收内存，减少内存占用**”，但再往深入问就回答不出来了。

鉴于网上有太多关于此问题的误导，本文将通过实例，深入JVM剖析“对象不再使用时赋值为null”这一操作存在的意义，供君参考。

#### X.2.2.示例代码

我们来看看一段非常简单的代码：

```
public static void main(String[] args) {
    if (true) {
        byte[] placeHolder = new byte[64 * 1024 * 1024];
        System.out.println(placeHolder.length / 1024);
    }
    System.gc();
}
```

我们在if中实例化了一个数组placeHolder，然后在if的作用域外通过System.gc();手动触发了GC，其用意是回收placeHolder，因为placeHolder已经无法访问到了。

来看看输出：

```
65536
[GC 68239K->65952K(125952K), 0.0014820 secs]
[Full GC 65952K->65881K(125952K), 0.0093860 secs]
```

`Full GC 65952K->65881K(125952K)` 代表的意思是：本次GC后，内存占用从65952K降到了65881K。意思其实是说GC没有将placeHolder回收掉，是不是不可思议？

下面来看看遵循“不使用的对象应手动赋值为null“的情况：

```
public static void main(String[] args) {
    if (true) {
        byte[] placeHolder = new byte[64 * 1024 * 1024];
        System.out.println(placeHolder.length / 1024);
        placeHolder = null;
    }
    System.gc();
}
```

其输出为：

```
65536
[GC 68239K->65952K(125952K), 0.0014910 secs]
[Full GC 65952K->345K(125952K), 0.0099610 secs]
```

这次GC后内存占用下降到了345K，即placeHolder被成功回收了！对比两段代码，仅仅将placeHolder赋值为null就解决了GC的问题，真应该感谢“不使用的对象应手动赋值为null“。

等等，为什么例子里placeHolder不赋值为null，GC就“发现不了”placeHolder该回收呢？这才是问题的关键所在。

#### X.2.3.运行时栈

**X.2.3.1.典型的运行时栈**

如果你了解过编译原理，或者程序执行的底层机制，你会知道方法在执行的时候，方法里的变量（局部变量）都是分配在栈上的；当然，对于Java来说，new出来的对象是在堆中，但栈中也会有这个对象的指针，和int一样。

比如对于下面这段代码：

```
public static void main(String[] args) {
    int a = 1;
    int b = 2;
    int c = a + b;
}
```

其运行时栈的状态可以理解成：

| 索引 | 变量 |
| :--- | :--- |
| 1    | a    |
| 2    | b    |
| 3    | c    |

“索引”表示变量在栈中的序号，根据方法内代码执行的先后顺序，变量被按顺序放在栈中。

再比如：

```
public static void main(String[] args) {
    if (true) {
        int a = 1;
        int b = 2;
        int c = a + b;
    }
    int d = 4;
}
```

这时运行时栈就是：

| 索引 | 变量 |
| :--- | :--- |
| 1    | a    |
| 2    | b    |
| 3    | c    |
| 4    | d    |

容易理解吧？

其实仔细想想上面这个例子的运行时栈是有优化空间的。

**X.2.3.2.Java的栈优化**

上面的例子，main()方法运行时占用了4个栈索引空间，但实际上不需要占用这么多。当if执行完后，变量a、b和c都不可能再访问到了，所以它们占用的1～3的栈索引是可以“回收”掉的，比如像这样：

| 索引 | 变量 |
| :--- | :--- |
| 1    | a    |
| 2    | b    |
| 3    | c    |
| 1    | d    |

变量d重用了变量a的栈索引，这样就节约了内存空间。

**X.2.3.3.提醒**

上面的“运行时栈”和“索引”是为方便引入而故意发明的词，实际上在JVM中，它们的名字分别叫做“局部变量表”和“Slot”。而且局部变量表在编译时即已确定，不需要等到“运行时”。

**X.2.3.4.GC一瞥**

这里来简单讲讲主流GC里非常简单的一小块：如何确定对象可以被回收。另一种表达是，如何确定对象是存活的。

仔细想想，Java的世界中，对象与对象之间是存在关联的，我们可以从一个对象访问到另一个对象。如图所示。

![图片](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/20210505161255.webp)

再仔细想想，这些对象与对象之间构成的引用关系，就像是一张大大的图；更清楚一点，是众多的树。

如果我们找到了所有的树根，那么从树根走下去就能找到所有存活的对象，那么那些没有找到的对象，就是已经死亡的了！这样GC就可以把那些对象回收掉了。

现在的问题是，怎么找到树根呢？JVM早有规定，其中一个就是：**栈中引用的对象。也就是说，只要堆中的这个对象，在栈中还存在引用，就会被认定是存活的**。

**X.2.3.5.提醒**

上面介绍的确定对象可以被回收的算法，其名字是“可达性分析算法”。

**X.2.3.6.JVM的“bug”**

我们再来回头看看最开始的例子：

```
public static void main(String[] args) {
    if (true) {
        byte[] placeHolder = new byte[64 * 1024 * 1024];
        System.out.println(placeHolder.length / 1024);
    }
    System.gc();
}
```

看看其运行时栈：

```
LocalVariableTable:
Start  Length  Slot  Name   Signature
    0      21     0  args   [Ljava/lang/String;
    5      12     1 placeHolder   [B
```

栈中第一个索引是方法传入参数args，其类型为String[]；第二个索引是placeHolder，其类型为byte[]。

联系前面的内容，我们推断placeHolder没有被回收的原因：System.gc();**触发GC时，main()方法的运行时栈中，还存在有对args和placeHolder的引用，GC判断这两个对象都是存活的，不进行回收**。

也就是说，代码在离开if后，虽然已经离开了placeHolder的作用域，但在此之后，没有任何对运行时栈的读写，placeHolder所在的索引还没有被其他变量重用，所以GC判断其为存活。

为了验证这一推断，我们在System.gc();之前再声明一个变量，按照之前提到的“Java的栈优化”，这个变量会重用placeHolder的索引。

```
public static void main(String[] args) {
    if (true) {
        byte[] placeHolder = new byte[64 * 1024 * 1024];
        System.out.println(placeHolder.length / 1024);
    }
    int replacer = 1;
    System.gc();
}
```

看看其运行时栈：

```
LocalVariableTable:
Start  Length  Slot  Name   Signature
    0      23     0  args   [Ljava/lang/String;
    5      12     1 placeHolder   [B
   19       4     1 replacer   I
```

不出所料，replacer重用了placeHolder的索引。来看看GC情况：

```
65536
[GC 68239K->65984K(125952K), 0.0011620 secs]
[Full GC 65984K->345K(125952K), 0.0095220 secs]
```

placeHolder被成功回收了！我们的推断也被验证了。

再从运行时栈来看，加上int replacer = 1;和将placeHolder赋值为null起到了同样的作用：断开堆中placeHolder和栈的联系，让GC判断placeHolder已经死亡。

现在算是理清了“不使用的对象应手动赋值为null“的原理了，一切根源都是来自于JVM的一个“bug”：代码离开变量作用域时，并不会自动切断其与堆的联系。为什么这个“bug”一直存在？你不觉得出现这种情况的概率太小了么？算是一个tradeoff了。

X.2.4.总结

希望看到这里你已经明白了“不使用的对象应手动赋值为null“这句话背后的奥义。

我比较赞同《深入理解Java虚拟机》作者的观点：在需要“**不使用的对象应手动赋值为null**“时大胆去用，**但不应当对其有过多依赖，更不能当作是一个普遍规则来推广。**

























