# 垃圾回收相关算法

## 标记阶段：引用计数算法

### 垃圾标记阶段：对象存活判断

- 在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为已经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。
- 那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。
- 判断对象存活一般有两种方式：引用计数算法和可达性分析算法。




### 方式一：引用计数算法

- 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
- 对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。
- 优点：实现简单，垃圾对象便于辨别；判定效率高，回收没有延迟性。
- 缺点：
  - 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
  - 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
  - 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。

### 循环引用

![image-20210204211853536](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/image-20210204211853536.png)

![image-20210204211914325](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/image-20210204211914325.png)

![image-20210204211947631](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/image-20210204211947631.png)



### 小结

- 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。

- 具体哪种最优是看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。
- Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。
- Python 如何解决循环引用？
  - 手动解除：很好理解，就是在合适的时机，解除引用关系。
  - 使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。



## 标记阶段：可达性分析算法

### 方式二：可达性分析（或根搜索算法、追踪性垃圾收集）

- 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
- 相较于引用计数算法，这里的可达性分析就是 Java、C# 选择的。这种类型的垃圾收集通常也叫做追踪性垃圾收集（Tracing Garbage Collection）。
- 所谓 “GC Roots” 根集合就是一组必须活跃的引用。
- 基本思路：
  - 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
  - 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）
  - 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。
  - 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

![image-20210204214830438](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/image-20210204214830438.png)

### GC Roots

在 Java 语言中，GC Roots 包括以下几类元素：

- 虚拟机栈中引用的对象
  - 比如：各个线程被调用的方法中使用到的参数、局部变量等。
- 本地方法栈内 JNI （通常说的本地方法）引用的对象
- 方法区中类静态属性引用的对象
  - 比如：Java 类的引用类型静态变量
- 所有被同步锁 synchronized 持有的对象
- Java 虚拟机内部的引用
  - 基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError)，系统类加载器。
- 反映 Java 虚拟机内部情况的 JMXBean、JVMTI中注册的回调、本地代码缓存等。

![image-20210204215357731](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/image-20210204215357731.png)

- 除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（Partial GC）。
  - 如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GC Roots 集合中去考虑，才能保证可达性分析的准确性。
- 小技巧：由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。



### 注意

- 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析的准确性就无法保证。
- 这点也是导致 GC 进行时必须 “Stop The World” 的一个重要原因。
  - 即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。







## 对象的 finalization 机制

### 对象的 finalization 机制

- Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
- 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize() 方法。
- finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。
- 永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用。理由包括下面三点：
  - 在 finalize() 时可能会导致对象复活。
  - finalize() 方法的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生GC，则finalize() 会严重影响 GC 的性能。
- 从功能上来说，finalize() 方法与 C++ 中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize() 方法在本质上不同于 C++ 中的析构函数。
- 由于 finalize() 方法的存在，虚拟机中的对象一般处于是那种可能的状态。



### 生成还是死亡？

- 如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了 。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此定义虚拟机中的对象可能的三种状态。如下：
  - 可触及的：从根节点开始，可以到达这个对象。
  - 可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活。
  - 不可触及的：对象的 finalize() 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 finalize() 只会被调用一次。
- 以上3种状态中，是由于 finalize() 方法的存在，进行的区分。只有在对象不可触及时才可以被回收。



### 具体过程

判断一个对象 objA 是否可回收，至少要经历两次标记过程：

1. 如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记。
2. 进行筛选，判断此对象是否有必要执行 finalize() 方法
   - 如果对象 objA 没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。
   - 如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行。
   - finalize() 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上的任何一个对象建立了联系，那么第二次标记时，objA 会被移出”即将回收“集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize() 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize() 方法只会被调用一次。





## MAT 与 JProfiler 的 GC Roots 溯源

![image-20210204232832040](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/image-20210204232832040.png)



### 获取 dump 文件

![image-20210204232859414](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/image-20210204232859414.png)



![image-20210204232916679](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/jvm-demo/image-20210204232916679.png)





## 清除阶段：标记-清楚算法









## 清除阶段：复制算法







## 清除阶段：标记-压缩算法











## 小结













## 分代收集算法













## 增量收集算法、分区算法



















