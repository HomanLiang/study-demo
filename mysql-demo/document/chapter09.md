[toc]

# MySQL 性能优化





## 什么影响了数据库查询速度
### 影响数据库查询速度的四个因素
![Image](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/mysql-demo/20210307113301.png)
### 风险分析
> QPS： QueriesPerSecond意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。
>
> TPS： 是 TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。

Tips： 最好不要在主库上数据库备份，大型活动前取消这样的计划。

1. 效率低下的 sql：超高的 QPS与 TPS。
2. 大量的并发：数据连接数被占满（ max_connection默认 100，一般把连接数设置得大一些）。 并发量:同一时刻数据库服务器处理的请求数量
3. 超高的 CPU使用率： CPU资源耗尽出现宕机。
4. 磁盘 IO：磁盘 IO性能突然下降、大量消耗磁盘性能的计划任务。解决：更快磁盘设备、调整计划任务、做好磁盘维护。
### 网卡流量：如何避免无法连接数据库的情况
减少从服务器的数量（从服务器会从主服务器复制日志）

进行分级缓存（避免前端大量缓存失效）

避免使用 select* 进行查询

分离业务网络和服务器网络
### 大表带来的问题
**大表的特点**

- 记录行数巨大，单表超千万
- 表数据文件巨大，超过 10个 G

**大表的危害**

- 慢查询：很难在短时间内过滤出需要的数据 查询字区分度低 -> 要在大数据量的表中筛选出来其中一部分数据会产生大量的磁盘 io -> 降低磁盘效率
- 对 DDL影响：
  - 建立索引需要很长时间：
  MySQL-v<5.5 建立索引会锁表
  MySQL-v>=5.5 建立索引会造成主从延迟（ mysql建立索引，先在组上执行，再在库上执行）
  - 修改表结构需要长时间的锁表：会造成长时间的主从延迟('480秒延迟')

**如何处理数据库上的大表**

> 分库分表把一张大表分成多个小表

难点：
1. 分表主键的选择
2. 分表后跨分区数据的查询和统计

### 大事务带来的问题
**什么是事务**

![Image [2]](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/mysql-demo/20210307113302.png)

**大事务**

> 运行时间长，操作数据比较多的事务；

风险：锁定数据太多，回滚时间长，执行时间长。
- 锁定太多数据，造成大量阻塞和锁超时；
- 回滚时所需时间比较长，且数据仍然会处于锁定；
- 如果执行时间长，将造成主从延迟，因为只有当主服务器全部执行完写入日志时，从服务器才会开始进行同步，造成延迟。

解决思路：
- 避免一次处理太多数据，可以分批次处理；
- 移出不必要的SELECT操作，保证事务中只有必要的写操作。



## 什么影响了MySQL性能

### 影响性能的几个方面
1. 服务器硬件。
2. 服务器系统（系统参数优化）。
3. 存储引擎。 MyISAM： 不支持事务，表级锁。 InnoDB: 支持事务，支持行级锁，事务 ACID。
4. 数据库参数配置。
5. 数据库结构设计和SQL语句。（重点优化）

### MySQL体系结构
分三层：客户端->服务层->存储引擎  
![Image [3]](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/mysql-demo/20210307113403.png)

1. MySQL是 插件式的存储引擎，其中存储引擎分很多种。只要实现符合mysql存储引擎的接口，可以开发自己的存储引擎!
2. 所有跨存储引擎的功能都是在服务层实现的。
3. MySQL的存储引擎是针对表的，不是针对库的。也就是说在一个数据库中可以使用不同的存储引擎。但是不建议这样做。
### 如何选择正确的存储引擎
参考条件：
1. 事务
2. 备份( Innobd免费在线备份)
3. 崩溃恢复
4. 存储引擎的特有特性

总结: Innodb 大法好。

注意: 尽量别使用混合存储引擎，比如回滚会出问题在线热备问题。

### 配置参数
**内存配置相关参数**

- 确定可以使用的内存上限。
- 内存的使用上限不能超过物理内存，否则容易造成内存溢出；（对于32位操作系统，MySQL只能试用3G以下的内存。）
- 确定MySQL的 每个连接 单独 使用的内存。

```
sort_buffer_size #定义了每个线程排序缓存区的大小，MySQL在有查询、需要做排序操作时才会为每个缓冲区分配内存（直接分配该参数的全部内存）；
join_buffer_size #定义了每个线程所使用的连接缓冲区的大小，如果一个查询关联了多张表，MySQL会为每张表分配一个连接缓冲，导致一个查询产生了多个连接缓冲；
read_buffer_size #定义了当对一张MyISAM进行全表扫描时所分配读缓冲池大小，MySQL有查询需要时会为其分配内存，其必须是4k的倍数；
read_rnd_buffer_size #索引缓冲区大小，MySQL有查询需要时会为其分配内存，只会分配需要的大小。
```
注意： 以上四个参数是为一个线程分配的，如果有100个连接，那么需要×100。
MySQL数据库实例：
- MySQL是 单进程多线程（而oracle是多进程），也就是说 MySQL实例在系统上表现就是一个服务进程，即进程；
- MySQL实例是线程和内存组成，实例才是真正用于操作数据库文件的；

> 一般情况下一个实例操作一个或多个数据库；集群情况下多个实例操作一个或多个数据库。

**如何为缓存池分配内存：**

Innodb_buffer_pool_size，定义了Innodb所使用缓存池的大小，对其性能十分重要，必须足够大，但是过大时，使得Innodb 关闭时候需要更多时间把脏页从缓冲池中刷新到磁盘中；
```
总内存-（每个线程所需要的内存*连接数）-系统保留内存
```
key_buffer_size，定义了MyISAM所使用的缓存池的大小，由于数据是依赖存储操作系统缓存的，所以要为操作系统预留更大的内存空间；
```
select sum(index_length) from information_schema.talbes where engine='myisam'
```
注意： 即使开发使用的表全部是Innodb表，也要为MyISAM预留内存，因为MySQL系统使用的表仍然是MyISAM表。

max_connections 控制允许的最大连接数， 一般2000更大。

不要使用外键约束保证数据的完整性。
### 性能优化顺序
从上到下：
![Image [4]](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/mysql-demo/20210307113404.png)



## 优化方法

### 单表优化
除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量：
#### 字段
- 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED
- VARCHAR的长度只分配真正需要的空间
- 使用枚举或整数代替字符串类型
- 尽量使用TIMESTAMP而非DATETIME，
- 单表不要有太多字段，建议在20以内
- 避免使用NULL字段，很难查询优化且占用额外索引空间
- 用整型来存IP
#### 索引
- 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描
- 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描
- 值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段
- 字符字段只建前缀索引
- 字符字段最好不要做主键
- 不用外键，由程序保证约束
- 尽量不用UNIQUE，由程序保证约束
- 使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引
#### 查询SQL
- EXPLAIN
做MySQL优化，我们要善用EXPLAIN查看SQL执行计划。
下面来个简单的示例，标注（1、2、3、4、5）我们要重点关注的数据：
![Image [5]](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/mysql-demo/20210307113505.png)
> type列，连接类型。一个好的SQL语句至少要达到range级别。杜绝出现all级别。
> key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式
> key_len列，索引长度。
> rows列，扫描行数。该值是个预估值。
> extra列，详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。
- 可通过开启慢查询日志来找出较慢的SQL
- 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边
- sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库
- 不用SELECT *
- OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内
- 不用函数和触发器，在应用程序实现
- 避免%xxx式查询
- 少用JOIN
- 使用同类型进行比较，比如用'123'和'123'比，123和123比
- 尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描
- 对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5
- 列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大
- SQL语句中IN包含的值不应过多
MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from t where num in(1,2,3) 对于连续的数值，能用between就不要用in了；再或者使用连接来替换。
- 当只需要一条数据的时候，使用limit 1
这是为了使EXPLAIN中type列达到const类型五、如果排序字段没有用到索引
- 如果排序字段没有用到索引，就尽量少排序
- 尽量用union all代替union
union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据。
- 不使用ORDER BY RAND()
```
select id from `dynamic` order by rand() limit 1000;
```
上面的SQL语句，可优化为：
```
select id from `dynamic` t1 join (select rand() * (select max(id) from `dynamic`) as nid) t2 on t1.id > t2.nidlimit 1000;
```
- 使用合理的分页方式以提高分页的效率
```
select id,name from product limit 866613, 20
```
使用上述SQL语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。
优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。SQL可以采用如下的写法：
```
select id,name from product where id> 866612 limit 20
```
- 避免在where子句中对字段进行表达式操作
- 避免隐式类型转换
- 对于联合索引来说，要遵守最左前缀法则
举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面。

#### 引擎
目前广泛使用的是MyISAM和InnoDB两种引擎：

**MyISAM**

MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：
- 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁
- 不支持事务
- 不支持外键
- 不支持崩溃后的安全恢复
- 在表有读取查询的同时，支持往表中插入新纪录
- 支持BLOB和TEXT的前500个字符索引，支持全文索引
- 支持延迟更新索引，极大提升写入性能
- 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用

**InnoDB**

InnoDB在MySQL 5.5后成为默认索引，它的特点是：
- 支持行锁，采用MVCC来支持高并发
- 支持事务
- 支持外键
- 支持崩溃后的安全恢复
- 不支持全文索引

ps: 据说innodb已经在mysql 5.6.4支持全文索引了

总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表
#### 系统调优参数
可以使用下面几个工具来做基准测试：
- sysbench：一个模块化，跨平台以及多线程的性能测试工具
- iibench-mysql：基于 Java 的 MySQL/Percona/MariaDB 索引进行插入性能测试工具
- tpcc-mysql：Percona开发的TPC-C测试工具

具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数：
- back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500
- wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时
- max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限
- thread_concurrency：并发线程数，设为CPU核数的两倍
- skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问
- key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询show status like 'key_read%'，保证key_reads / key_read_requests在0.1%以下最好
- innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询show status like 'Innodb_buffer_pool_read%'，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests越高越好
- innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小
- innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB
- query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大.
- 可以通过命令show status like 'Qcache_%'查看目前系统Query catch使用大小
- read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能
- sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小
- read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。
- record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值
- thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的
- table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM

#### 升级硬件
Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能

#### Schema与数据类型优化
1. 整数通常是标识列最好的选择，因为它们很快并且可以使用AUTO_INCREMENT
1. 完全“随机”的字符串（如：MD5()、SHA1()或者UUID()等产生的字符串）会任意分布在很大的空间内，会导致INSERT以及一些SELECT语句变的很慢
1. 如果希望查询执行得快速且并发性好，单个查询最好不要做太多的关联查询（互联网公司非常忌讳关联查询），利用程序来完成关联操作
1. 如果需要对一张比较大的表做表结构变更（ALTER TABLE操作增加一列），建议先拷贝一张与原表结构一样的表，再将数据复制进去，最后通过重命名将新表的表名称修改为原表的表名称。因为在变更表结构的时候很有可能会锁住整个表，并且可能会有长时间的不可用
1. 避免多表关联的时候可以适当考虑一些反范式的建表方案，增加一些冗余字段

#### InnoDB索引优化
1. 如果不是按照索引的最左列开始查找，则无法使用索引
1. 所有的非聚簇索引都需要先通过索引定位到对应的主键，然后在到聚簇索引查找数据，所以在定义主键索引的时候一定要谨慎
1. 只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或者正序）都一样时，MySQL才能够使用索引来对结果做排序。有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。
1. 在使用like来匹配字符串类型的字段的值时，尽可能的使用前缀匹配like ‘XX%’，避免使用 like ‘%XX’
1. 哈希索引是基于哈希表实现的，只有精确匹配索引所有列的查询才有效，也不遵循索引的最左匹配原则
1. 当服务器需要对多个索引做联合操作时（通常有多个OR条件），建议修改成UNION的方式，这样方便命中索引
1. 对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列
1. 尽可能多的使用覆盖索引（如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引），通过EXPLAIN的Extra列可以看到“Using index”信息
1. 当ID为主键时，创建索引(A)，相当于创建了(A)和(A, ID)两个索引
1. 表中的索引越多对SELECT、UPDATE和DELETE操作速度变慢，同时占用的内存也会比较多
1. InnoDB在二级索引上使用共享锁，但是访问主键索引需要排他锁
1. 尽可能的使用WHERE IN和WHERE BETWEEN AND的方式来进行范围查询
1. LIMIT的偏移量越大性能越慢
1. 编写查询语句时应该避免单行查找、尽可能的使用数据原生顺序从而避免额外的排序操作，并尽可能使用索引覆盖查询

#### 查询性能优化
- 对于低效的查询，通常从两个方面来分析：
    - 确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候可能是访问了太多的列
    - 确认MySQL服务器层是否在分析大量超过需要的数据行
- 一般MySQL能够使用以下三种方式应用WHERE条件，从好到坏依次为：
    - 在索引中使用WHERE条件俩过滤不匹配的记录
    - 使用索引覆盖扫描来返回记录
    - 从数据表中返回数据，然后过滤不满足条件的记录
- MySQL从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。在一个通用服务器上，也能够运行每秒超过10万的查询，一个千兆网卡也能轻松满足每秒超过2000次的查询，MySQL内部每秒能够扫描内存中上百万行数据
- 在删除大量数据时，建议每次删除一小批量数据后，暂停一会儿再做下一次的删除
- 无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序
- COUNT()函数有两种不同的作用：它可以统计某个列值的数量，也可以统计行数。最简单的就是通过`COUNT(*)`来统计行数
- 关联查询的时候要确保关联的字段上有索引
- 在数据量很大并且历史数据需要定期删除的情况下，可以考虑使用分区表
- 如果定了的索引列和分区列不匹配，会导致查询无法进行分区过滤
- 外键约束尽可能避免，通常通过程序来实现，心中要有外键
- 触发器、存储过程、自定义函数等最好不要使用
- 尽可能的利用查询缓存，如果在写查询语句的时候有一些不确定的数据（NOW()或者CURRENT_DATE()等）时，则不会被缓存
- 用多个小表代替一个大表对查询缓存有好处
- 批量写入时只需要做一次缓存失效，所以相比单条写入（每写入一次，缓存就失效）效率更好，对于写密集型的应用，直接禁用查询缓存
- 如果缓存的空间太大，在过期操作的时候可能会导致服务器僵死