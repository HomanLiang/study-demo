[toc]



# Linux 安全

Linux 作为 MINIX 和 UNIX 的衍生操作系统，从一开始就是一个`多用户`系统。这意味着 Linux 从早期开始就建立了安全和信息访问控制机制。下面我们主要探讨的就是 Linux 安全性的一些内容

## 1.Linux 安全基本概念

一个 Linux 系统的用户群里由一系列注册用户组成，他们每一个都有一个唯一的 UID (User ID)。一个 UID 是一个位于 0 到 65535 之间的整数。文件（进程或者是其他资源）都标记了它的所有者的 UID。默认情况下，文件的所有者是创建文件的人，文件的所有者是创建文件的用户。

用户可以被分成许多组，每个组都会由一个 16 位的整数标记，这个组叫做 `GID(组 ID)`。给用户分组是手动完成的，它由系统管理员执行，分组就是在数据库中添加一条记录指明哪个用户属于哪个组。一个用户可以属于不同组。

Linux 中的基本安全机制比较容易理解，每个进程都会记录它所有者的 UID 和 GID。当文件创建后，它会获取创建进程的 UID 和 GID。当一个文件被创建时，它的 UID 和 GID 就会被标记为进程的 UID 和 GID。这个文件同时会获取由该进程决定的一些权限。这些权限会指定所有者、所有者所在组的其他用户及其他用户对文件具有什么样的访问权限。对于这三类用户而言，潜在的访问权限是 **读、写和执行**，分别由 r、w 和 x 标记。当然，执行文件的权限仅当文件时可逆二进制程序时才有意义。试图执行一个拥有执行权限的非可执行文件，系统会报错。

**Linux 用户分为三种**

- `root（超级管理员）`，它的 UID 为 0，这个用户有极大的权限，可以直接无视很多的限制 ，包括读写执行的权限。
- `系统用户`，UID 为 1～499。
- `普通用户`，UID 范围一般是 500～65534。这类用户的权限会受到基本权限的限制，也会受到来自管理员的限制。不过要注意 nobody 这个特殊的帐号，UID 为 65534，这个用户的权限会进一步的受到限制，一般用于实现来宾帐号。

Linux 中的每类用户由 3 个比特为来标记，所以 9 个比特位就能够表示所有的权限。

下面来看一下一些基本的用户和权限例子

| 二进制    | 标记      | 准许的文件访问权限             |
| --------- | --------- | ------------------------------ |
| 111000000 | rwx------ | 所有者可读、写和执行           |
| 111111000 | rwxrwx--- | 所有者和组可以读、写和执行     |
| 111111111 | rwxrwxrwx | 所有人可以读、写和执行         |
| 000000000 | --------- | 任何人不拥有任何权限           |
| 000000111 | ------rwx | 只有组以外的其他用户拥有所有权 |
| 110100100 | rw-r--r-- | 所有者可以读和写，其他人可以读 |
| 110100100 | rw-r----- | 所有者可以读和写，组可以读     |

我们上面提到，UID 为 0 的是一个特殊用户，称为 `超级用户(或者根用户)`。超级用户能够读和写系统中的任何文件，不管这个文件由谁所有，也不管这个文件的保护模式如何。 UID 为 0 的进程还具有少数调用受保护系统调用的权限，而普通用户是不可能有这些功能的。通常情况下，只有系统管理员知道超级用户的密码。

在 Linux 系统下，目录也是一种文件，并且具有和普通文件一样的保护模式。不同的是，目录的 x 比特位表示查找权限而不是执行权限。因此，如果一个目录的保护模式是 `rwxr-xr-x`，那么它允许所有者读、写和查找目录，而其他人只可以读和查找，而不允许从中添加或者删除目录中的文件。

与 I/O 有关的特殊文件拥有和普通文件一样的保护位。这种机制可以用来限制对 I/O 设备的访问权限。举个例子，打印机是特殊文件，它的目录是 `/dev/lp`，它可以被根用户或者一个叫守护进程的特殊用户拥有，具有保护模式 `rw-------`，从而阻止其他所有人对打印机的访问。毕竟每个人都使用打印机的话会发生混乱。

当然，如果 `/dev/lp` 的保护模式是 `rw-------`，那就意味着其他任何人都不能使用打印机。

这个问题通过增加一个保护位 `SETUID` 到之前的 9 个比特位来解决。当一个进程的 SETUID 位打开，它的 `有效 UID` 将变成相应可执行文件的所有者 UID，而不是当前使用该进程的用户的 UID。将访问打印机的程序设置为守护进程所有，同时打开 SETUID 位，这样任何用户都可以执行此程序，而且拥有守护进程的权限。

除了 SETUID 之外，还有一个 SETGID 位，SETGID 的工作原理和 SETUID 类似。但是这个位一般很不常用。

## 2.Linux 安全相关的系统调用

Linux 中关于安全的系统调用不是很多，只有几个，如下列表所示

| 系统调用 | 描述                               |
| -------- | ---------------------------------- |
| chmod    | 改变文件的保护模式                 |
| access   | 使用真实的 UID 和 GID 测试访问权限 |
| chown    | 改变所有者和组                     |
| setuid   | 设置 UID                           |
| setgid   | 设置 GID                           |
| getuid   | 获取真实的 UID                     |
| getgid   | 获取真实的 GID                     |
| geteuid  | 获取有效的 UID                     |
| getegid  | 获取有效的 GID                     |

我们在日常开发中用到最多的就是 `chmod`了，没想到我们日常开发过程中也能用到系统调用啊，chmod 之前我们一直认为是改变权限，现在专业一点是改变文件的保护模式。它的具体函数如下

```shell
s = chmod("路径名","值");
```

例如

```shell
s = chmod("/usr/local/cxuan",777);
```

他就是会把 `/usr/local/cxuan` 这个路径的保护模式改为 rwxrwxrwx，任何组和人都可以操作这个路径。只有该文件的所有者和超级用户才有权利更改保护模式。

`access` 系统调用用来检验实际的 UID 和 GID 对某文件是否拥有特定的权限。下面就是四个 getxxx 的系统调用，这些用来获取 uid 和 gid 的。

> 注意：其中的 chown、setuid 和 setgid 是超级用户才能使用，用来改变所有者进程的 UID 和 GID。

## 3.Linux 安全实现

当用户登录时，登录程序，也被称为 `login`，会要求输入用户名和密码。它会对密码进行哈希处理，然后在 `/etc/passwd` 中进行查找，看看是否有匹配的项。使用哈希的原因是防止密码在系统中以非加密的方式存在。如果密码正确，登录程序会在 `/etc/passwd` 中读取用户选择的 shell 程序的名称，有可能是 `bash`，有可能是 `shell` 或者其他的 `csh` 或 `ksh`。然后登录程序使用 `setuid` 和 `setgid` 这两个系统调用来把自己的 UID 和 GID 变为用户的 UID 和 GID，然后它打开键盘作为标准输入、标准输入的文件描述符是 0 ，屏幕作为标准输出，文件描述符是 1 ，屏幕也作为标准错误输出，文件描述符为 2。最后，执行用户选择的 shell 程序，终止。

当任何进程想要打开一个文件，系统首先将文件的 `i - node` 所记录的保护位与用户有效 UID 和 有效 GID 进行对比，来检查访问是否允许。如果访问允许，就打开文件并返回文件描述符；否则不打开文件，返回 - 1。

Linux 安全模型和实现在本质上与大多数传统的 UNIX 系统相同。



## 4.用户与用户组管理

### 4.1.多用户多任务

Linux 是一个多用户、多任务的操作系统。比如通过远程访问，多个用户可以同时登陆一个系统并执行各自的多个任务。

用户在系统中是分角色的，并通过UID和GID进行区分。UID就是用户ID，GID就是群组的ID号。在Linux 系统中，由于角色不同，权限和所完成的任务也不同。

用户大体分为虚拟用户和实体用户：

- root 用户：系统管理员，可以登录系统，拥有最高权限。
- 虚拟用户：这类用户也被称之为伪用户或假用户，与真实用户区分开来，这类用户不具有登录系统的能力，但却是系统运行不可缺少的用户，比如 `bin`、`daemon`、`adm`、`ftp`、`mail` 等；这类用户都是系统自身拥有的，而非后来添加的，当然我们也可以添加虚拟用户。 （比如 `nobody` 和 `ftp` 等，我们访问 `LinuxSir.Org` 的网页程序，就是 `nobody` 用户；我们匿名访问 `ftp` 时，会用到用户 `ftp` 或 `nobody`）
- 普通实体用户：这类用户能登录系统，但只能操作自己家目录的内容，权限有限，是系统管理员自行添加的。

多用户机制使得系统管理更为方便，同时也使得系统更为安全。不同用户通过权限控制可以用于完成不同的工作。



### 4.2.用户(user）和用户组（group）概念

用户组（group）就是具有相同特征的用户（user）的集合体。 比如我们需要对几个用户采用相同的控制操作，那么我们可以将这几个用户加入同一个用户组，通过控制和修改该用户组来达到同时控制几个用户的目的。

用户和用户组的对应关系是：一对一、多对一、一对多或多对多；

- 一对一：某个用户可以是某个组的唯一成员；
- 多对一：多个用户可以是某个唯一的组的成员，不归属其它用户组；比如 `beinan` 和 `linuxsir` 两个用户只归属于 `beinan` 用户组；
- 一对多：某个用户可以是多个用户组的成员；比如 `beinan` 可以是root组成员，也可以是 `linuxsir` 用户组成员，还可以是adm用户组成员；
- 多对多：多个用户对应多个用户组，并且几个用户可以是归属相同的组；其实多对多的关系是前面三条的扩展；理解了上面的三条，这条也能理解；



### 4.3.用户和用户组相关的配置文件

**4.3.1.`/etc/passwd` 文件**

通常在Linux系统中，用户的关键信息被存放在系统的 `/etc/passwd` 文件中，系统的每一个合法用户账号对应于该文件中的一行记录，这行记录定义了每个用户账号的属性，其格式为：

```
用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
```

其内容示例如下：

```
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
...
```

- 用户名，即代表用户账号的字符串。
- 口令，通常口令字段中只存放一个特别的字符，例如“x”或“*”。而真正的加密后的用户口令则存放到 `/etc/shadow` 文件。
- 用户标识号，系统内部用来标识用户。如果几个用户名对应的用户标识号是相同的，系统内部将把他们视为同一个用户，不过他们能有不同的口令、不同的主目录及不同的登录Shell等。0是终极用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。
- 组标识号，记用户所属的用户组，对应着 `/etc/group` 文件中的一条记录。
- 注释性描述，通常是一段任意的注释性描述文字，用做finger命令的输出。
- 主目录，用户的起始工作目录，他是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。
- 登陆shell。用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程式，即Shell。Shell是用户和Linux系统之间的接口。 系统管理员能根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为 `/bin/sh`。（Win10 linux子系统下为 `/bin/bash`）

**4.3.2.`/etc/shadow` 文件**

该文件只有root用户可以访问，同样保存了加密的帐号信息。其格式为：

```
用户名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
```

其内容示例如下：

```
root:*:17255:0:99999:7:::
daemon:*:17255:0:99999:7:::
bin:*:17255:0:99999:7:::
sys:*:17255:0:99999:7:::
sync:*:17255:0:99999:7:::
games:*:17255:0:99999:7:::
...
```

- 用户名，同 `/etc/passwd` 文件中一致。
- 口令，同 `/etc/passwd` 文件中一致。
- 最后一次修改时间，表示的是从某个时刻起，到用户最后一次修改口令时的天数。一些系统中默认时间起点为1970年1月1日。
- 最小时间间隔，指的是两次修改口令之间所需的最小天数。
- 最大时间间隔，指的是口令保持有效的最大天数。
- 警告时间，字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
- 不活动时间，表示的是用户没有登录活动但账号仍能保持有效的最大天数。
- 失效时间，字段给出的是个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是个合法的账号，也就不能再用来登录了。

**4.3.3.`/etc/group` 文件**

用户组信息保存在 `/etc/group` 配置文件中，任何用户均可读取。用户组的加密密码保存在 `/etc/gshadow` 配置文件中。其格式为：

```
组名:口令:组标识号:组内用户列表
```

其内容示例如下：

```
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:syslog
...
```

### 4.4.用户和用户组相关的控制指令

**4.4.1.管理用户的工具或命令**

- useradd 或 adduser： 添加用户
- passwd： 为用户设置密码
- usermod： 修改用户属性，如登录名、用户的home目录等
- pwcov： 同步用户从 `/etc/passwd` 到 `/etc/shadow`
- pwck： 校验用户配置文件/etc/passwd 和/etc/shadow 文件内容是否合法或完整；
- pwunconv：与pwconv功能相反，用来关闭用户的投影密码。它会把密码从shadow文件内，重回存到passwd文件里，然后删除 `/etc/shadow` 文件。
- finger：查看用户信息工具
- id：查看用户的UID、GID及所归属的用户组
- chfn：更改用户信息工具
- su：用户切换工具
- sudo：用来以其他身份来执行命令，预设的身份为root。在 `/etc/sudoers` 中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。
- visudo： 用于编辑 `/etc/sudoers` 的命令；也可以不用这个命令，直接用vi 来编辑 `/etc/sudoers` 的效果是一样的。

**4.4.2.管理用户组的工具或命令**

该部分命令与“用户”命令很相似。

- groupadd：添加用户组
- groupdel：删除用户组
- groupmod：修改用户组信息
- groups：显示用户所属的用户组
- grpck：用于验证组文件的完整性
- grpconv：通过 `/etc/group` 和 `/etc/gshadow` 的文件内容来同步或创建 `/etc/gshadow`，如果 `/etc/gshadow` 不存在则创建；
- grpunconv：通过 `/etc/group` 和 `/etc/gshadow` 文件内容来同步或创建 `/etc/group` ，然后删除gshadow文件；
  

## 5.权限管理

Linux是多用户的操作系统，允许多个用户同时在系统上登录和工作。 为了**确保**系统和用户的**安全**，Linux自然就有自己一套的权限管理机制了！

相信用过Linux的同学在检索文件夹文件的时候常常用到`ls -l`的命令，会出来一大串的数据。这些数据你能读懂了吗？

例如：

```
drwxr-xr-x   3  osmond   osmond    4096  05-16 13:32   nobp
```

其实很简单：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/linux-demo/20210411201952.webp)

其实我们看权限就是看`drwxr-xr-x`这么一串东西，看起来很复杂，但不是的，一下就可以理解了。我们来分解一下：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/linux-demo/20210411202039.webp)

这9个字符**每3个一组**，组成 3 套 权限控制

- 第一套控制文件**所有者**的访问权限
- 第二套控制所有者**所在用户组**的其他成员的访问权限
- 第三套控制**系统其他用户**的访问权限

**rwx**分别代表的意思：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/linux-demo/20210411202055.webp)

看到这里来，如果前面的你看懂了，那`drwxr-xr-x`这么一串东西我觉得你很容易就能理解了：

- d是文件夹，后面还有9个字母，每3个分成一组，

  `-` 号表示没有。那么这个文件夹的权限就是：**对当前用户是可读可写可执行，对同组的用户是可读可执行，对其他的用户是可读可执行**

是不是很简单？？`r-read,w-write,x-execute`，很好理解的。

对于这些rwx命令为了方便还可以换成八进制的数据来表示，我相信大家看完下面的demo也知道其实就这么一回事了：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/linux-demo/20210411202234.webp)

**权限的优先顺序**：

- 如果UID匹配，就应用用户属主（user）权限
- 否则，如果GID匹配，就应用组（group）权限
- 如果都不匹配，就应用其它用户（other）权限
- **超级用户root具有一切权限**，无需特殊说明



### 5.1.管理Linux权限的常用命令

```
  chmod
```

  - 改变文件或目录的权限

```
  chown
```

  - 改变文件或目录的属主（所有者）

```
  chgrp
```

  - 改变文件或目录所属的组

```
  umask
```

  - 设置文件的缺省生成掩码

例子：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/linux-demo/20210411203217.webp)

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/linux-demo/20210411203625.webp)

### 5.2.权限扩展知识

上面提到了umask属性，它用来做这样的东西的：默认生成掩码告诉系统当创建一个文件或目录时**不应该赋予其哪些权限**。

- 默认的umask的值是022，我们看一下下面的例子应该就能懂了：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/linux-demo/20210411203639.webp)

除了上面所说的权限之外，Linux还提供了**三种特殊的权限**：

- SUID：使用命令的**所属用户的权限来运行**，而不是命令执行者的权限
- SGID：使用命令的**组权限来运行**。
- Sticky-bit：目录中的文件**只能被文件的所属用户和root用户删除**。

它们是这样表示的：

- SUID和SGID用s表示；Sticky-bit用t表示
- SUID是占用属主的x位置来表示
- SGID是占用组的x位置来表示
- sticky-bit是占用其他人的x位置来表示

例如：`drwxrwxrwt 5 root root 4096 06-18 01:01 /tmp`它就拥有sticky-bit权限。`-rwsr-xr-x 1 root root 23420 2010-08-11 /usr/bin/passwd`它就拥有SUID权限

SUID，SGID，sticky-bit同样也有数字的表示法：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/linux-demo/20210411204146.webp)

使用的例子：

![img](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/linux-demo/20210411204156.webp)

Linux内核中有大量安全特征。EXT2/3/4**文件系统的扩展属性**（Extended Attributes）可以在某种程度上保护系统的安全

**常见的扩展属性：**

- A（Atime）：告诉系统不要修改对这个文件的最后访问时间。
  - **使用A属性可以提高一定的性能**。
- S（Sync）：一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘。
  - **使用S属性能够最大限度的保障文件的完整性**。
- a（Append Only）：系统只允许在这个文件之后追加数据，不允许任何进程覆盖或者截断这个文件。如果目录具有这个属性，系统将 只允许在这个目录下建立和修改文件，而不允许删除任何文件。
- i（Immutable）：系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件。
  - **a属性和i属性对于提高文件系统的安全性和保障文件系统的完整性有很大的好处**。

**常用命令**：

- 显示扩展属性：`lsattr [-adR] [文件|目录]`
- 修改扩展属性：`chattr [-R] [[-+=][属性]] <文件|目录>`



