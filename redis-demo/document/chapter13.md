[toc]



# Redis 最佳实践

## Key的设计

### 易于管理

- 即能通过名称大概知道所涉及业务。通常我们会以 `service:characteristics` 来进行命名，如 `pubg_chat:uid:room_id` 的形式，这样可以尽可能避免冲突（当然，不同业务使用不同的Redis是更好的）

### 尽量简洁

- Redis本质上是一个内存数据库，而内存的大小是远小于硬盘的。如果Key过大的话，会导致Redis所能存储的内容变少。所以在日常中推荐Key能够尽可能的简介明了，用缩写来代替完整的单词

### 避免特殊字符

- 如逗号、换行、空格和引号等转义字符都是不应该使用的

### 设置生命周期

- Redis不应当成为一个永久存储的组件，为每一个Key都设置他的过期时间
- 如果确实需要Redis永久存储某类内容，那么因当采用异步“续命”的方式来进行，而不应该在一开始就为其设置永久的生命周期，避免后续需要变更时带来的维护灾难



## Value的使用

### 规避大value

- Redis单线程的，它会在执行完一个命令后才会执行其他命令
- 首先大Key在传输键值对时，会对网络造成压力（带宽问题），并且有的 `proxy` 会将大内容分片传输，进而再次增加了网络传输时间
- 其次，如 `list`、`hash`  这类结构，如果使用 `O(n)` 的指令或者使用 `del` 命令，那么会造成严重的阻塞
- 所以通常而言，`string`  类型控制在 `10KB` 以内，`hash`、`list`、`set`、`zset` 元素个数不要超过 5000
- ps：通常可采用 `hash` 的方式分割大key

### value的压缩

可考虑使用 `protobuf`、`MessagePack` 等方式进行序列化，这样一可以提升redis的利用率，二提高了序列化的效率，三是能提供value跨语言的能力



## 命令使用

### 避免使用的命令

- 避免频繁对string做append，可以考虑使用`list`进行替代

- `O(n)`指令应注意。对于set，zset，list，hash等集合类，应注意O（n）命令对于性能的影响。通常应该避免直接使用O（n）指令，可用HSCAN，SSCAN，ZSCAN进行渐进操作，防止命令的阻塞
- 渐进式删除。不应该直接使用del，而应该自己写脚本一点点的删除

- 不使用复杂度过高的命令，例如SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE，使用这些命令耗时较久，会阻塞主线程
- 如部分Redis Client会有TestOnBorrow之类的探测指令，在没有特殊要求的情况下应当避免此类指令，以减小redis负载和网络压力

### 禁用危险命令

- keys、flushall、flushdb......这种不用多说，一来直接Redis就懵圈了，人也楞了
- 禁止使用KEYS命令，需要扫描实例时，建议使用SCAN，线上操作一定要控制扫描的频率，避免对Redis产生性能抖动

### 合理利用Pipeline模式

- 在mget大量数据时，proxy会拆包和解包，会导致proxy层的压力增加，而pipeline模式会直接转发。所以在批量获取的情况下，**pipeline的效率一般都会优于mget**
- 同时应该注意两点：
  - mget是原子操作，pipeline不是。所以业务上不可盲目采用
  - pipeline是可以发送不同命令的，当然使用lua也可以实现这一点

### 对Lua应当做特殊要求

- 所有key都应该由KEYS数组来传递
- 所有value都应该由ARGS数组来传递
- 所有key，必须在1个slot上

### 性能查询指令

- `slowlog get`，查询慢命令
- `info commandstats`，查询执行过的命令信息，包含用时和次数等
- `client list`，查询引起阻塞的命令

### 不滥用Redis事务

Redis事务不像DB的事务这么“安全”，也不支持回滚，所以不应当过多的使用。因为这块我没怎么使用过，详见[官方文档](https://redis.io/topics/transactions)

### 其他

- 查询数据时，一次尽量获取较少的数据，在不确定容器元素个数的情况下，避免使用LRANGE key 0 -1，ZRANGE key 0 -1这类操作，应该设置具体查询的元素个数，推荐一次查询100个以下元素
- 写入数据时，一次尽量写入较少的数据，例如HSET key value1 value2 value3...，-控制一次写入元素的数量，推荐在100以下，大数据量分多个批次写入
- 批量操作数据时，用MGET/MSET替换GET/SET、HMGET/MHSET替换HGET/HSET，减少请求来回的网络IO次数，降低延迟，对于没有批量操作的命令，推荐使用pipeline，一次性发送多个命令到服务端
- 避免某个时间点集中过期大量的key，集中过期时推荐增加一个随机时间，把过期时间打散，降低集中过期key时Redis的压力，避免阻塞主线程
- 读的请求量很大时，推荐使用读写分离，前提是可以容忍从节数据更新不及时的问题
- 写请求量很大时，推荐使用集群，部署多个实例分摊写压力



## 客户端使用

### 建议操作

- 使用连接池，并配置合理的连接池参数。每次使用都新建连接会有几个问题：

  - 造成redis的负担增加
- 浪费网络资源，避免短连接，TCP三次握手和四次挥手的耗时也很高
  - 影响执行效率
  - 难以维护
  
- 熔断：Redis本质也是一个“服务”，所以熔断机制不可少

- 鉴权：避免无关服务的滥用或导致数据出错

- 只使用db0，不推荐使用多个db，使用多个db会增加Redis的负担，每次访问不同的db都需要执行SELECT命令，如果业务线不同，建议拆分多个实例，还能提高单个实例的性能

- 不同业务线部署不同的实例，各自独立，避免混用，推荐不同业务线使用不同的机器，根据业务重要程度划分不同的分组来部署，避免某一个业务线出现问题影响其他业务线

### 避免操作

- 避免混用实例：不同的业务线应该做到实例的拆分，避免混用导致的连锁问题：如key重合、命令阻塞等

- 避免作为消息队列：Redis其实还能够支持消息队列的应用，但其读写效率是不及其他MQ如Kafka、RabbitMQ等。且由于其结构的设置，不太能够支撑MQ的一些主要特性，所以应当避免使用。





## 运维层面

### 建议操作

- Redis 4.0以上建议开启lazy-free机制，释放大value时异步操作，不阻塞主线程
- 保证机器有足够的CPU、内存、带宽、磁盘资源，防止负载过高影响Redis性能
- 以master-slave集群方式部署实例，并分布在不同机器上，避免单点，slave必须设置为readonly
- master和slave节点所在机器，各自独立，不要交叉部署实例，通常备份工作会在slave上做，做备份时会消耗机器资源，交叉部署会影响到master的性能
- 推荐部署哨兵节点增加可用性，节点数量至少3个，并分布在不同机器上，实现故障自动故障转移
- 提前做好容量规划，一台机器部署实例的内存上限，最好是机器内存的一半，主从全量同步时会占用最多额外一倍的内存空间，防止网络大面积故障引发所有master-slave的全量同步导致机器内存被吃光
- 做好机器的CPU、内存、带宽、磁盘监控，在资源不足时及时报警处理，Redis使用Swap后性能急剧下降，网络带宽负载过高访问延迟明显增大，磁盘IO过高时开启AOF会拖慢Redis的性能
- 设置最大连接数上限，防止过多的客户端连接导致服务负载过高
- 单个实例的使用内存建议控制在20G以下，过大的实例会导致备份时间久、资源消耗多，主从全量同步数据时间阻塞时间更长
- 设置合理的slowlog阈值，推荐10毫秒，并对其进行监控，产生过多的慢日志需要及时报警 设置合理的复制缓冲区repl-backlog大小，适当调大repl-backlog可以降低主从全量复制的概率
- 设置合理的slave节点client-output-buffer-limit大小，对于写入量很大的实例，适当调大可以避免主从复制中断问题
- 备份时推荐在slave节点上做，不影响master性能
- 不开启AOF或开启AOF配置为每秒刷盘，避免磁盘IO消耗降低Redis性能
- 当实例设置了内存上限，需要调大内存上限时，先调整slave再调整master，否则会导致主从节点数据不一致
- 对Redis增加监控，监控采集info信息时，使用长连接，频繁的短连接也会影响Redis性能，[redis性能监控指标](http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&mid=2247495171&idx=2&sn=b1097b73768ae4fb5c2b7e8747e2fae7&chksm=e9188b1fde6f0209e70af9066722e097941ac30214b02e6ad4fdb88ddc62c39d4f203ae9d610&scene=21#wechat_redirect)，参考这个文章
- 线上扫描整个实例数时，记得设置休眠时间，避免扫描时QPS突增对Redis产生性能抖动
- 做好Redis的运行时监控，尤其是expired_keys、evicted_keys、latest_fork_usec指标，短时间内这些指标值突增可能会阻塞整个实例，引发性能问题

- 选择合适的**淘汰策略**

  根据⾃⾝业务类型，选好maxmemory-policy(最⼤内存淘汰策略)，设置好过期时间 默认策略是volatile-lru，即超过最⼤内存后，在过期键中使⽤lru算法进⾏key的剔除，保证不过期数据不被 删除，但是可能会出现OOM问题

  - `allkeys-lru`：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出⾜够空间为⽌
  - `allkeys-random`：随机删除所有键，直到腾出⾜够空间为⽌。
	- `volatile-random`:随机删除过期键，直到腾出⾜够空间为⽌
	- `volatile-ttl`：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略
	- `noeviction`：不会剔除任何数据，拒绝所有写⼊操作并返回客⼾端错误信息"(error) OOM command not allowed when used memory"，此时Redis只响应读操作
	- 4.0后推出的 `allkey-lfu` 和 `volatile-lfu`
	  - 可以认为这是对于lru算法的进一步改进
	  - `allkey-lfu`：从所有键中驱逐使用频率最少的键
	  - `volatile-lfu`：从所有配置了过期时间的键中驱逐使用频率最少的键


