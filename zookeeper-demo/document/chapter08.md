[toc]



# ZooKeeper 应用场景

`ZooKeeper` 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 `ZooKeeper` 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、`Master` 选举、分布式锁和分布式队列等功能

## 1.统一命名服务

在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，进程对象等等——这些我们都可以统称他们为**名字**（`Name`）。其中较为常见的就是一些分布式服务框架（如 `RPC`、`RMI`）中的服务地址列表。通过调用 `Zookeeper` 提供的创建节点的 `API`，能够很容易创建一个全局唯一的 `path`，这个 `path` 就可以作为一个名称。

阿里巴巴开源的分布式服务框架 `Dubbo` 就使用 `ZooKeeper` 来作为其命名服务，维护全局的服务地址列表。

## 2.数据发布与订阅（配置中心）

发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到 `ZooKeeper` 节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。

1. 分布式环境下，配置文件管理和同步是一个常见问题
   - 一个集群中，所有节点的配置信息是一致的，比如 `Hadoop` 集群、集群中的数据库配置信息等全局配置
   - 对配置文件修改后，希望能够快速同步到各个节点上。
2. 配置管理可交由 `ZooKeeper` 实现
   - 可将配置信息写入 `ZooKeeper` 上的一个 `Znode`
   - 各个节点监听这个 `Znode`
   - 一旦 `Znode` 中的数据被修改，`ZooKeeper` 将通知各个节点

![image-20210313160114149](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/zookeeper-demo/20210313160114.png)

## 3.统一集群管理

所谓集群管理无在乎两点：是否有机器退出和加入、选举 `Master`。

### 3.1.管理节点

1. 分布式环境中，**实时掌握**每个节点的状态是必要的，比如我们要知道集群中各机器状态、收集各个机器的运行时状态数据、服务器动态上下线等。
2. 交由 `ZooKeeper` 实现的方式
   - 可将节点信息写入 `ZooKeeper` 上的一个 `Znode`
   - 监听这个 `Znode` 可获取它的实时状态变化
   - 典型应用：`HBase` 中 `Master` 状态监控和选举。

![image-20210313160209538](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/zookeeper-demo/20210313160209.png)

### 3.2.Master选举

在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络 `I/O` 处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个 `master` 选举便是这种场景下的碰到的主要问题。

利用 `Zookeeper` 的强一致性，能够很好的保证在分布式高并发情况下节点的创建一定是全局唯一的，即：同时有多个客户端请求创建 `/currentMaster` 节点，最终一定只有一个客户端请求能够创建成功。`Zookeeper` 通过这种节点唯一的特性，可以创建一个 `Master` 节点，其他客户端 `Watcher` 监控当前 `Master` 是否存活，一旦 `Master` 挂了，其他机器再创建这样的一个 `Master` 节点，用来重新选举。

## 4.软负载均衡

分布式系统中，负载均衡是一种很普遍的技术，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。可以是硬件的负载均衡，如 `F5`，也可以是软件的负载，我们熟知的 `Nginx`，或者这里介绍的 `Zookeeper`。

![image-20210313160254371](https://homan-blog.oss-cn-beijing.aliyuncs.com/study-demo/zookeeper-demo/20210313160254.png)

## 5.分布式协调/通知

`Zookeeper` 中特有的 「**Watcher**」 注册与异步通知机制，能够很好的实现分布式环境下不同机器，甚至不同系统之间的协调和通知，从而实现对数据变更的实时处理。

使用方法通常是不同系统都对 `ZK` 上同一个 `znode` 进行注册，监听 `znode` 的变化（包括 `znode` 本身内容及子节点的），其中一个系统 `update` 了 `znode`，那么另一个系统能够收到通知，并作出相应处理。

- 心跳检测中可以让检测系统和被检测系统之间并不直接关联起来，而是通过 `ZK` 上某个节点关联，减少系统耦合;
- 系统调度模式中，假设某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了 `ZK` 上某些节点的状态，而 `ZK` 就把这些变化通知给他们注册 `Watcher` 的客户端，即推送系统，于是，作出相应的推送任务。

## 6.分布式锁

分布式锁，这个主要得益于 `ZooKeeper` 为我们保证了数据的强一致性。

锁服务可以分为两类，一个是**保持独占**，另一个是**控制时序**。

- 所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把 `zk` 上的一个 `znode` 看作是一把锁，通过 `create znode` 的方式来实现。所有客户端都去创建 `/distribute_lock` 节点，最终成功创建的那个客户端也即拥有了这把锁。
- 控制时序，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 `/distribute_lock` 已预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：`CreateMode.EPHEMERAL_SEQUENTIAL`来指定）。`ZK` 的父节点（`/distribute_lock`）维持一份 `sequence`，保证子节点创建的时序性，从而也形成了每个客户端的全局时序。

个人感觉还是用 `Redis` 实现分布式锁更加方便。

> PS：阿里中间件团队：“其实，ZK 并非天生就是为这些应用场景设计的，都是后来众多开发者根据其框架的特性，利用其提供的一系列API接口（或者称为原语集），摸索出来的典型使用方法。”